###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                07/May/2015  10:56:13 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Com #
#                          ponents\stack\zdo\ZDSecMgr.c                       #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0 #
#                          \Projects\zstack\Samples\ParkingS\CC2530DB\..\..\. #
#                          .\Tools\CC2530DB\f8wEndev.cfg" (-DCPU32MHZ         #
#                          -DROOT=__near_func -DBLINK_LEDS) -f "C:\Texas      #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\Tools\CC253 #
#                          0DB\f8wConfig.cfg" (-DSECURE=0                     #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Co #
#                          mponents\stack\zdo\ZDSecMgr.c" -D ZIGBEEPRO -D     #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Samples\ParkingS\CC2530DB\EndDev #
#                          iceEB-Pro\List\" -lA "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\EndDeviceEB-Pro\List #
#                          \" --diag_suppress Pe001,Pa010 -o "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\EndDeviceEB-Pro\Obj\ #
#                          " -e --require_prototypes --debug --core=plain     #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\" -I "C:\Texas       #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\SOURCE\" -I       #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pr #
#                          ojects\zstack\Samples\ParkingS\CC2530DB\..\..\..\Z #
#                          MAIN\TI2530DB\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\MT\" -I "C:\Texas Instruments\ZStack-CC2530- #
#                          2.3.0-1.4.0\Projects\zstack\Samples\ParkingS\CC253 #
#                          0DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\" -I     #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pr #
#                          ojects\zstack\Samples\ParkingS\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\HAL\TARGET\CC2530EB\" -I           #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pr #
#                          ojects\zstack\Samples\ParkingS\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas      #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\OSAL\INCLUDE\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\STACK\AF\" -I "C:\Texas                      #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\STACK\NWK\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\STACK\SEC\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\STACK\SAPI\" -I "C:\Texas                    #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\STACK\SYS\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\STACK\ZDO\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\ZMAC\F8W\" -I "C:\Texas                      #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\ZMAC\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\SERVICES\SADDR\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\SERVICES\SDATA\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\MAC\INCLUDE\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\MAC\HIGH_LEVEL\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\MAC\LOW_LEVEL\srf04\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\ParkingS\CC2530DB\..\..\..\..\..\COMPO #
#                          NENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I         #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pro #
#                          jects\zstack\Samples\ParkingS\CC2530DB\EndDeviceEB #
#                          -Pro\List\ZDSecMgr.lst                             #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pro #
#                          jects\zstack\Samples\ParkingS\CC2530DB\EndDeviceEB #
#                          -Pro\Obj\ZDSecMgr.r51                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-01-08 13:29:59 -0800 (Fri, 08 Jan 2010) $
      4            Revision:       $Revision: 21465 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          
    123          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    124            // The number of times the frame counter can change before
    125            // saving to NV
    126            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    127          #endif
    128          
    129          /******************************************************************************
    130           * TYPEDEFS
    131           */
    132          typedef struct
    133          {
    134            uint8 extAddr[Z_EXTADDR_LEN];
    135            uint8 key[SEC_KEY_LEN];
    136          } ZDSecMgrPreConfigData_t;
    137          
    138          typedef struct
    139          {
    140            uint16 ami;
    141            uint8  key[SEC_KEY_LEN];
    142          } ZDSecMgrMasterKeyData_t;
    143          
    144          //should match APSME_LinkKeyData_t;
    145          typedef struct
    146          {
    147            uint8               key[SEC_KEY_LEN];
    148            APSME_LinkKeyData_t apsmelkd;
    149          } ZDSecMgrLinkKeyData_t;
    150          
    151          typedef struct
    152          {
    153            uint16                ami;
    154            ZDSecMgrLinkKeyData_t lkd;
    155            ZDSecMgr_Authentication_Option authenticateOption;
    156          } ZDSecMgrEntry_t;
    157          
    158          typedef struct
    159          {
    160            ZDSecMgrEntry_t* entry;
    161            uint16           parentAddr;
    162            uint8            secure;
    163            uint8            state;
    164            uint8            cntr;
    165            //uint8          next;
    166          } ZDSecMgrCtrl_t;
    167          
    168          typedef struct
    169          {
    170            uint16          nwkAddr;
    171            uint8*          extAddr;
    172            uint16          parentAddr;
    173            uint8           secure;
    174            uint8           devStatus;
    175            ZDSecMgrCtrl_t* ctrl;
    176          } ZDSecMgrDevice_t;
    177          
    178          /******************************************************************************
    179           * LOCAL VARIABLES
    180           */
    181          #if 0 // Taken out because the following functionality is only used for test
    182                // purpose. A more efficient (above) way is used. It can be put
    183                // back in if customers request for a white/black list feature.
    184          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    185          {
    186            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    187            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    188            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    189          };
    190          #endif
    191          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    193            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    194          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    195          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    196            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    197             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    198          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    199          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    200          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    201          
    202          //devtag.pro.security - remove this
    203          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    204          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    205          {
    206            //---------------------------------------------------------------------------
    207            // DEVICE A
    208            //---------------------------------------------------------------------------
    209            {
    210              // extAddr
    211              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    212          
    213              // key
    214              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    215               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    216            },
    217            //---------------------------------------------------------------------------
    218            // DEVICE B
    219            //---------------------------------------------------------------------------
    220            {
    221              // extAddr
    222              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    223          
    224              // key
    225              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    226               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    227            },
    228            //---------------------------------------------------------------------------
    229            // DEVICE C
    230            //---------------------------------------------------------------------------
    231            {
    232              // extAddr
    233              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    234          
    235              // key
    236              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    237               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    238            },
    239          };
    240          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    243          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    244          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    245          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    246          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    247          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    248          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    249          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    250          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    251          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    252          
    253          /******************************************************************************
    254           * PRIVATE FUNCTIONS
    255           *
    256           *   ZDSecMgrMasterKeyInit
    257           *   ZDSecMgrAddrStore
    258           *   ZDSecMgrExtAddrStore
    259           *   ZDSecMgrExtAddrLookup
    260           *   ZDSecMgrMasterKeyLookup
    261           *   ZDSecMgrMasterKeyStore
    262           *   ZDSecMgrEntryInit
    263           *   ZDSecMgrEntryLookup
    264           *   ZDSecMgrEntryLookupAMI
    265           *   ZDSecMgrEntryLookupExt
    266           *   ZDSecMgrEntryFree
    267           *   ZDSecMgrEntryNew
    268           *   ZDSecMgrCtrlInit
    269           *   ZDSecMgrCtrlRelease
    270           *   ZDSecMgrCtrlLookup
    271           *   ZDSecMgrCtrlSet
    272           *   ZDSecMgrCtrlAdd
    273           *   ZDSecMgrCtrlTerm
    274           *   ZDSecMgrCtrlReset
    275           *   ZDSecMgrMasterKeyLoad
    276           *   ZDSecMgrAppKeyGet
    277           *   ZDSecMgrAppKeyReq
    278           *   ZDSecMgrEstablishKey
    279           *   ZDSecMgrSendMasterKey
    280           *   ZDSecMgrSendNwkKey
    281           *   ZDSecMgrDeviceEntryRemove
    282           *   ZDSecMgrDeviceEntryAdd
    283           *   ZDSecMgrDeviceCtrlHandler
    284           *   ZDSecMgrDeviceCtrlSetup
    285           *   ZDSecMgrDeviceCtrlUpdate
    286           *   ZDSecMgrDeviceRemove
    287           *   ZDSecMgrDeviceValidateSKKE
    288           *   ZDSecMgrDeviceValidateRM
    289           *   ZDSecMgrDeviceValidateCM
    290           *   ZDSecMgrDeviceValidate
    291           *   ZDSecMgrDeviceJoin
    292           *   ZDSecMgrDeviceJoinDirect
    293           *   ZDSecMgrDeviceJoinFwd
    294           *   ZDSecMgrDeviceNew
    295           *   ZDSecMgrAssocDeviceAuth
    296           *   ZDSecMgrAuthInitiate
    297           *   ZDSecMgrAuthNwkKey
    298           *   APSME_TCLinkKeyInit
    299           *   APSME_IsDefaultTCLK
    300           */
    301          //-----------------------------------------------------------------------------
    302          // master key data
    303          //-----------------------------------------------------------------------------
    304          void ZDSecMgrMasterKeyInit( void );
    305          
    306          //-----------------------------------------------------------------------------
    307          // address management
    308          //-----------------------------------------------------------------------------
    309          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    310          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    311          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    312          
    313          //-----------------------------------------------------------------------------
    314          // MASTER key data
    315          //-----------------------------------------------------------------------------
    316          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    317          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    318          
    319          //-----------------------------------------------------------------------------
    320          // entry data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrEntryInit(uint8 state);
    323          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    324          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    325          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    326          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    327          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    328          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    329          
    330          //-----------------------------------------------------------------------------
    331          // control data
    332          //-----------------------------------------------------------------------------
    333          void ZDSecMgrCtrlInit( void );
    334          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    335          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    336          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    337                                ZDSecMgrEntry_t*  entry,
    338                                ZDSecMgrCtrl_t*   ctrl );
    339          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    340          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    341          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    342                                       ZDSecMgrEntry_t*  entry );
    343          
    344          //-----------------------------------------------------------------------------
    345          // key support
    346          //-----------------------------------------------------------------------------
    347          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    348          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    349                                       uint8*  initExtAddr,
    350                                       uint16  partNwkAddr,
    351                                       uint8*  partExtAddr,
    352                                       uint8** key,
    353                                       uint8*  keyType );
    354          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    355          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    356          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    357          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    358          
    359          //-----------------------------------------------------------------------------
    360          // device entry
    361          //-----------------------------------------------------------------------------
    362          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    363          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    364          #if defined NV_RESTORE
    365          static void ZDSecMgrWriteNV(void);
    366          static void ZDSecMgrRestoreFromNV(void);
    367          #endif
    368          
    369          //-----------------------------------------------------------------------------
    370          // device control
    371          //-----------------------------------------------------------------------------
    372          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    373          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    374          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    375          
    376          //-----------------------------------------------------------------------------
    377          // device management
    378          //-----------------------------------------------------------------------------
    379          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    382          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    383          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    384          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    385          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    386          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    387          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    388          
    389          //-----------------------------------------------------------------------------
    390          // association management
    391          //-----------------------------------------------------------------------------
    392          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    393          
    394          //-----------------------------------------------------------------------------
    395          // authentication management
    396          //-----------------------------------------------------------------------------
    397          void ZDSecMgrAuthInitiate( uint8* responder );
    398          void ZDSecMgrAuthNwkKey( void );
    399          
    400          //-----------------------------------------------------------------------------
    401          // APSME function
    402          //-----------------------------------------------------------------------------
    403          void APSME_TCLinkKeyInit( void );
    404          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    405          
    406          /******************************************************************************
    407           * @fn          ZDSecMgrMasterKeyInit                     ]
    408           *
    409           * @brief       Initialize master key data.
    410           *
    411           * @param       none
    412           *
    413           * @return      none
    414           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    415          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    416          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    417            uint16 index;
    418            uint16 size;
    419          
    420            // allocate MASTER key data
    421            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    422          
    423            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A36         MOV     R2,#0x36
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000E   12....       LCALL   ?Subroutine13 & 0xFFFF
    424          
    425            // initialize MASTER key data
    426            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_19:
   \   000011   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrMasterKeyInit_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   000019   601F         JZ      ??ZDSecMgrMasterKeyInit_1
    427            {
    428              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    429              {
    430                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F012       MOV     B,#0x12
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   ACF0         MOV     R4,B
   \   00002B   75F012       MOV     B,#0x12
   \   00002E   EB           MOV     A,R3
   \   00002F   A4           MUL     AB
   \   000030   2C           ADD     A,R4
   \   000031   FB           MOV     R3,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000035   12....       LCALL   ?Subroutine2 & 0xFFFF
    431              }
    432            }
   \                     ??CrossCallReturnLabel_105:
   \   000038   40E5         JC      ??ZDSecMgrMasterKeyInit_2
    433          }
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   00003A   02....       LJMP    ??Subroutine100_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000006                REQUIRE ??Subroutine85_0
   \   000006                ; // Fall through to label ??Subroutine85_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine85_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FC           MOV     R4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   8C82         MOV     DPL,R4
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   E8           MOV     A,R0
   \   000001   2401         ADD     A,#0x1
   \   000003   08           INC     R0
   \   000004   E9           MOV     A,R1
   \   000005   3400         ADDC    A,#0x0
   \   000007   F9           MOV     R1,A
   \   000008   C3           CLR     C
   \   000009   E8           MOV     A,R0
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   E9           MOV     A,R1
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine100_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   74FE         MOV     A,#-0x2
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   74FF         MOV     A,#-0x1
   \   000006   22           RET
    434          //devtag.pro.security
    435          #if 0
    436          void ZDSecMgrMasterKeyInit( void )
    437          {
    438            uint16         index;
    439            uint16         size;
    440            AddrMgrEntry_t entry;
    441          
    442          
    443            // allocate MASTER key data
    444            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    445          
    446            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    447          
    448            // initialize MASTER key data
    449            if ( ZDSecMgrMasterKeyData != NULL )
    450            {
    451              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    452              {
    453                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    454              }
    455          
    456              // check if preconfigured keys are enabled
    457              //-------------------------------------------------------------------------
    458              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    459              //-------------------------------------------------------------------------
    460              if ( zgPreConfigKeys == TRUE )
    461              {
    462                // sync configured data
    463                entry.user = ADDRMGR_USER_SECURITY;
    464          
    465                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    466                {
    467                  // check for Address Manager entry
    468                  AddrMgrExtAddrSet( entry.extAddr,
    469                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    470          
    471                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    472                  {
    473                    // update Address Manager
    474                    AddrMgrEntryUpdate( &entry );
    475                  }
    476          
    477                  if ( entry.index != INVALID_NODE_ADDR )
    478                  {
    479                    // sync MASTER keys with Address Manager index
    480                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    481          
    482                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    483                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    484                  }
    485                }
    486              }
    487              //-------------------------------------------------------------------------
    488              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    489              //-------------------------------------------------------------------------
    490            }
    491          }
    492          #endif
    493          
    494          /******************************************************************************
    495           * @fn          ZDSecMgrAddrStore
    496           *
    497           * @brief       Store device addresses.
    498           *
    499           * @param       nwkAddr - [in] NWK address
    500           * @param       extAddr - [in] EXT address
    501           * @param       ami     - [out] Address Manager index
    502           *
    503           * @return      ZStatus_t
    504           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    505          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    506          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine19 & 0xFFFF
    507            ZStatus_t      status;
    508            AddrMgrEntry_t entry;
    509          
    510          
    511            // add entry
    512            entry.user    = ADDRMGR_USER_SECURITY;
    513            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_33:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine12 & 0xFFFF
    514            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_16:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine50 & 0xFFFF
    515          
    516            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_84:
   \   00001E   700A         JNZ     ??ZDSecMgrAddrStore_0
    517            {
    518              // return successful results
    519              *ami   = entry.index;
   \   000020   740B         MOV     A,#0xb
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   12....       LCALL   ?Subroutine7 & 0xFFFF
    520              status = ZSuccess;
    521            }
   \                     ??CrossCallReturnLabel_110:
   \   000028   8008         SJMP    ??CrossCallReturnLabel_28
    522            else
    523            {
    524              // return failed results
    525              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00002A   740B         MOV     A,#0xb
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   12....       LCALL   ?Subroutine14 & 0xFFFF
    526              status = ZNwkUnknownDevice;
    527            }
    528          
    529            return status;
   \                     ??CrossCallReturnLabel_28:
   \   000032   02....       LJMP    ?Subroutine81 & 0xFFFF
    530          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000003   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000006   E9           MOV     A,R1
   \   000007   6401         XRL     A,#0x1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000003   E8           MOV     A,R0
   \   000004   FE           MOV     R6,A
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
   \   000007   7402         MOV     A,#0x2
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   7401         MOV     A,#0x1
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000003   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000006   79C8         MOV     R1,#-0x38
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005   7403         MOV     A,#0x3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000003                REQUIRE ??Subroutine86_0
   \   000003                ; // Fall through to label ??Subroutine86_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine86_0:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003   7900         MOV     R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8E82         MOV     DPL,R6
   \   000007   8F83         MOV     DPH,R7
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   740D         MOV     A,#0xd
   \   000002   02....       LJMP    ??Subroutine95_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??AddrMgrExtAddrSet?relay
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D                REQUIRE ?Subroutine73
   \   00000D                ; // Fall through to label ?Subroutine73

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine95_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine96_0
   \   000003                ; // Fall through to label ??Subroutine96_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine96_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    531          
    532          /******************************************************************************
    533           * @fn          ZDSecMgrExtAddrStore
    534           *
    535           * @brief       Store EXT address.
    536           *
    537           * @param       extAddr - [in] EXT address
    538           * @param       ami     - [out] Address Manager index
    539           *
    540           * @return      ZStatus_t
    541           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    543          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine19 & 0xFFFF
    544            ZStatus_t      status;
    545            AddrMgrEntry_t entry;
    546          
    547          
    548            // add entry
    549            entry.user    = ADDRMGR_USER_SECURITY;
    550            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_34:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine12 & 0xFFFF
    551            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_17:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine50 & 0xFFFF
    552          
    553            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_85:
   \   00001E   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    554            {
    555              // return successful results
    556              *ami   = entry.index;
   \   000020   740B         MOV     A,#0xb
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   12....       LCALL   ?Subroutine7 & 0xFFFF
    557              status = ZSuccess;
    558            }
   \                     ??CrossCallReturnLabel_111:
   \   000028   8008         SJMP    ??CrossCallReturnLabel_29
    559            else
    560            {
    561              // return failed results
    562              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00002A   740B         MOV     A,#0xb
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   12....       LCALL   ?Subroutine14 & 0xFFFF
    563              status = ZNwkUnknownDevice;
    564            }
    565          
    566            return status;
   \                     ??CrossCallReturnLabel_29:
   \   000032   02....       LJMP    ?Subroutine81 & 0xFFFF
    567          }
    568          
    569          /******************************************************************************
    570           * @fn          ZDSecMgrExtAddrLookup
    571           *
    572           * @brief       Lookup index for specified EXT address.
    573           *
    574           * @param       extAddr - [in] EXT address
    575           * @param       ami     - [out] Address Manager index
    576           *
    577           * @return      ZStatus_t
    578           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    579          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    580          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    581            ZStatus_t      status;
    582            AddrMgrEntry_t entry;
    583          
    584          
    585            // lookup entry
    586            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   7402         MOV     A,#0x2
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
    587            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ?Subroutine65 & 0xFFFF
    588          
    589            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_158:
   \   000023   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000026   E9           MOV     A,R1
   \   000027   6401         XRL     A,#0x1
   \   000029   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    590            {
    591              // return successful results
    592              *ami   = entry.index;
   \   00002B   740B         MOV     A,#0xb
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ?Subroutine7 & 0xFFFF
    593              status = ZSuccess;
    594            }
   \                     ??CrossCallReturnLabel_112:
   \   000033   8008         SJMP    ??CrossCallReturnLabel_30
    595            else
    596            {
    597              // return failed results
    598              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000035   740B         MOV     A,#0xb
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   12....       LCALL   ?Subroutine14 & 0xFFFF
    599              status = ZNwkUnknownDevice;
    600            }
    601          
    602            return status;
   \                     ??CrossCallReturnLabel_30:
   \   00003D                REQUIRE ?Subroutine81
   \   00003D                ; // Fall through to label ?Subroutine81
    603          }
    604          
    605          /******************************************************************************
    606           * @fn          ZDSecMgrMasterKeyLookup
    607           *
    608           * @brief       Lookup MASTER key for specified address index.
    609           *
    610           * @param       ami - [in] Address Manager index
    611           * @param       key - [out] valid MASTER key
    612           *
    613           * @return      ZStatus_t
    614           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    615          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    616          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    617            ZStatus_t status;
    618            uint16    index;
    619          
    620          
    621            // initialize results
    622            *key   = NULL;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
    623            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
    624          
    625            // verify data is available
    626            if ( ZDSecMgrMasterKeyData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7002         JNZ     ??ZDSecMgrMasterKeyLookup_0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000017   6042         JZ      ??ZDSecMgrMasterKeyLookup_1
    627            {
    628              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000019   7E00         MOV     R6,#0x0
   \   00001B   7F00         MOV     R7,#0x0
    629              {
    630                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   00001D   8E..         MOV     ?V0 + 0,R6
   \   00001F   8F..         MOV     ?V0 + 1,R7
   \   000021   E5..         MOV     A,?V0 + 0
   \   000023   75F012       MOV     B,#0x12
   \   000026   A4           MUL     AB
   \   000027   F5..         MOV     ?V0 + 0,A
   \   000029   A8F0         MOV     R0,B
   \   00002B   75F012       MOV     B,#0x12
   \   00002E   E5..         MOV     A,?V0 + 1
   \   000030   A4           MUL     AB
   \   000031   28           ADD     A,R0
   \   000032   F5..         MOV     ?V0 + 1,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000037   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00003A   7003         JNZ     ??ZDSecMgrMasterKeyLookup_3
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   6B           XRL     A,R3
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   00003F   7015         JNZ     ??ZDSecMgrMasterKeyLookup_4
    631                {
    632                  // return successful results
    633                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   000041   E5..         MOV     A,?V0 + 0
   \   000043   2402         ADD     A,#0x2
   \   000045   F8           MOV     R0,A
   \   000046   E5..         MOV     A,?V0 + 1
   \   000048   3400         ADDC    A,#0x0
   \   00004A   F9           MOV     R1,A
   \   00004B   8C82         MOV     DPL,R4
   \   00004D   8D83         MOV     DPH,R5
   \   00004F   12....       LCALL   ??Subroutine86_0 & 0xFFFF
    634                  status = ZSuccess;
    635          
    636                  // break from loop
    637                  index  = ZDSECMGR_MASTERKEY_MAX;
   \                     ??CrossCallReturnLabel_113:
   \   000052   7E03         MOV     R6,#0x3
   \   000054   7F00         MOV     R7,#0x0
    638                }
    639              }
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   000056   12....       LCALL   ?Subroutine43 & 0xFFFF
    640            }
   \                     ??CrossCallReturnLabel_72:
   \   000059   40C2         JC      ??ZDSecMgrMasterKeyLookup_2
    641          
    642            return status;
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   00005B   80..         SJMP    ??Subroutine87_0
    643          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine87_0:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   25..         ADD     A,?V0 + 0
   \   000003   F5..         MOV     ?V0 + 0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   35..         ADDC    A,?V0 + 1
   \   000009   F5..         MOV     ?V0 + 1,A
   \   00000B   85..82       MOV     DPL,?V0 + 0
   \   00000E   F583         MOV     DPH,A
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6A           XRL     A,R2
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   EF           MOV     A,R7
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET
    644          
    645          /******************************************************************************
    646           * @fn          ZDSecMgrMasterKeyStore
    647           *
    648           * @brief       Store MASTER key for specified address index.
    649           *
    650           * @param       ami - [in] Address Manager index
    651           * @param       key - [in] valid key to store
    652           *
    653           * @return      ZStatus_t
    654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    655          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    656          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    657            ZStatus_t status;
    658            uint16    index;
    659            uint8*    entry;
    660          
    661          
    662            // initialize results
    663            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
    664          
    665            // verify data is available
    666            if ( ZDSecMgrMasterKeyData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7002         JNZ     ??ZDSecMgrMasterKeyStore_0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000017   606D         JZ      ??ZDSecMgrMasterKeyStore_1
    667            {
    668              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7B00         MOV     R3,#0x0
    669              {
    670                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   00001D   EA           MOV     A,R2
   \   00001E   FC           MOV     R4,A
   \   00001F   EB           MOV     A,R3
   \   000020   FD           MOV     R5,A
   \   000021   EC           MOV     A,R4
   \   000022   75F012       MOV     B,#0x12
   \   000025   A4           MUL     AB
   \   000026   FC           MOV     R4,A
   \   000027   A8F0         MOV     R0,B
   \   000029   75F012       MOV     B,#0x12
   \   00002C   ED           MOV     A,R5
   \   00002D   A4           MUL     AB
   \   00002E   28           ADD     A,R0
   \   00002F   FD           MOV     R5,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000033   E0           MOVX    A,@DPTR
   \   000034   2C           ADD     A,R4
   \   000035   FC           MOV     R4,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   3D           ADDC    A,R5
   \   000039   FD           MOV     R5,A
   \   00003A   8C82         MOV     DPL,R4
   \   00003C   8D83         MOV     DPH,R5
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   64FE         XRL     A,#0xfe
   \   000041   7004         JNZ     ??ZDSecMgrMasterKeyStore_3
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   000047   7038         JNZ     ??ZDSecMgrMasterKeyStore_4
    671                {
    672                  // store EXT address index
    673                  ZDSecMgrMasterKeyData[index].ami = ami;
   \   000049   12....       LCALL   ?Subroutine9 & 0xFFFF
    674          
    675                  entry = ZDSecMgrMasterKeyData[index].key;
   \                     ??CrossCallReturnLabel_224:
   \   00004C   EC           MOV     A,R4
   \   00004D   2402         ADD     A,#0x2
   \   00004F   FA           MOV     R2,A
   \   000050   ED           MOV     A,R5
   \   000051   3400         ADDC    A,#0x0
   \   000053   FB           MOV     R3,A
    676          
    677                  if ( key != NULL )
   \   000054   EE           MOV     A,R6
   \   000055   7001         JNZ     ??ZDSecMgrMasterKeyStore_5
   \   000057   EF           MOV     A,R7
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   000058   6018         JZ      ??ZDSecMgrMasterKeyStore_6
    678                  {
    679                    osal_memcpy( entry, key,  SEC_KEY_LEN );
   \   00005A                ; Setup parameters for call to function osal_memcpy
   \   00005A   8E..         MOV     ?V0 + 4,R6
   \   00005C   8F..         MOV     ?V0 + 5,R7
   \   00005E   75..00       MOV     ?V0 + 6,#0x0
   \   000061   78..         MOV     R0,#?V0 + 4
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000066   7C10         MOV     R4,#0x10
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   12....       LCALL   ?Subroutine67 & 0xFFFF
    680                  }
   \                     ??CrossCallReturnLabel_243:
   \   00006D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000070   8009         SJMP    ??ZDSecMgrMasterKeyStore_7
    681                  else
    682                  {
    683                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   000072                ; Setup parameters for call to function osal_memset
   \   000072   7C10         MOV     R4,#0x10
   \   000074   7D00         MOV     R5,#0x0
   \   000076   7900         MOV     R1,#0x0
   \   000078   12....       LCALL   ??osal_memset?relay
    684                  }
    685          
    686                  // return successful results
    687                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_7:
   \   00007B   7900         MOV     R1,#0x0
    688          
    689                  // break from loop
    690                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   00007D   7A03         MOV     R2,#0x3
   \   00007F   7B00         MOV     R3,#0x0
    691                }
    692              }
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000081   12....       LCALL   ?Subroutine45 & 0xFFFF
    693            }
   \                     ??CrossCallReturnLabel_78:
   \   000084   4097         JC      ??ZDSecMgrMasterKeyStore_2
    694          
    695            return status;
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   000086   7F07         MOV     R7,#0x7
   \   000088   02....       LJMP    ?BANKED_LEAVE_XDATA
    696          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   EA           MOV     A,R2
   \   000001   2401         ADD     A,#0x1
   \   000003   0A           INC     R2
   \   000004   EB           MOV     A,R3
   \   000005   3400         ADDC    A,#0x0
   \   000007   FB           MOV     R3,A
   \   000008   C3           CLR     C
   \   000009   EA           MOV     A,R2
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   EB           MOV     A,R3
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   8C82         MOV     DPL,R4
   \   000002   8D83         MOV     DPH,R5
   \   000004                REQUIRE ??Subroutine112_0
   \   000004                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E5..         MOV     A,?V0 + 1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET
    697          
    698          /******************************************************************************
    699           * @fn          ZDSecMgrEntryInit
    700           *
    701           * @brief       Initialize entry sub module
    702           *
    703           * @param       state - device initialization state
    704           *
    705           * @return      none
    706           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    707          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    708          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    709            if (ZDSecMgrEntries == NULL)
   \   000004   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7002         JNZ     ??ZDSecMgrEntryInit_0
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryInit_0:
   \   00000C   7036         JNZ     ??ZDSecMgrEntryInit_1
    710            {
    711              uint16 index;
    712          
    713              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E   7A57         MOV     R2,#0x57
   \   000010   7B00         MOV     R3,#0x0
   \   000012   12....       LCALL   ??osal_mem_alloc?relay
   \   000015   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000018   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00001B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7002         JNZ     ??ZDSecMgrEntryInit_2
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryInit_2:
   \   000023   601F         JZ      ??ZDSecMgrEntryInit_1
    714              {
    715                return;
    716              }
    717          
    718              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000025   7800         MOV     R0,#0x0
   \   000027   7900         MOV     R1,#0x0
    719              {
    720                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_3:
   \   000029   E8           MOV     A,R0
   \   00002A   FA           MOV     R2,A
   \   00002B   E9           MOV     A,R1
   \   00002C   FB           MOV     R3,A
   \   00002D   EA           MOV     A,R2
   \   00002E   75F01D       MOV     B,#0x1d
   \   000031   A4           MUL     AB
   \   000032   FA           MOV     R2,A
   \   000033   ACF0         MOV     R4,B
   \   000035   75F01D       MOV     B,#0x1d
   \   000038   EB           MOV     A,R3
   \   000039   A4           MUL     AB
   \   00003A   2C           ADD     A,R4
   \   00003B   FB           MOV     R3,A
   \   00003C   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003F   12....       LCALL   ?Subroutine2 & 0xFFFF
    721              }
    722            }
   \                     ??CrossCallReturnLabel_106:
   \   000042   40E5         JC      ??ZDSecMgrEntryInit_3
   \                     ??ZDSecMgrEntryInit_1:
   \   000044   02....       LJMP    ??Subroutine100_0 & 0xFFFF
    723          
    724          #if defined NV_RESTORE
    725            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    726            {
    727              ZDSecMgrRestoreFromNV();
    728            }
    729          #else
    730            (void)state;
    731          #endif
    732          }
    733          
    734          /******************************************************************************
    735           * @fn          ZDSecMgrEntryLookup
    736           *
    737           * @brief       Lookup entry index using specified NWK address.
    738           *
    739           * @param       nwkAddr - [in] NWK address
    740           * @param       entry   - [out] valid entry
    741           *
    742           * @return      ZStatus_t
    743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    744          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    745          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    746            ZStatus_t      status;
    747            uint16         index;
    748            AddrMgrEntry_t addrMgrEntry;
    749          
    750          
    751            // initialize results
    752            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    753            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    754          
    755            // verify data is available
    756            if ( ZDSecMgrEntries != NULL )
   \   000019   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   7002         JNZ     ??ZDSecMgrEntryLookup_0
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryLookup_0:
   \   000021   6068         JZ      ??ZDSecMgrEntryLookup_1
    757            {
    758              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000023   7402         MOV     A,#0x2
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
    759              addrMgrEntry.nwkAddr = nwkAddr;
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine1 & 0xFFFF
    760          
    761              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_139:
   \   000034   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000037   E9           MOV     A,R1
   \   000038   6401         XRL     A,#0x1
   \   00003A   704F         JNZ     ??ZDSecMgrEntryLookup_1
    762              {
    763                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00003C   7800         MOV     R0,#0x0
   \   00003E   7900         MOV     R1,#0x0
    764                {
    765                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_2:
   \   000040   E8           MOV     A,R0
   \   000041   FA           MOV     R2,A
   \   000042   E9           MOV     A,R1
   \   000043   FB           MOV     R3,A
   \   000044   EA           MOV     A,R2
   \   000045   75F01D       MOV     B,#0x1d
   \   000048   A4           MUL     AB
   \   000049   FA           MOV     R2,A
   \   00004A   ACF0         MOV     R4,B
   \   00004C   75F01D       MOV     B,#0x1d
   \   00004F   EB           MOV     A,R3
   \   000050   A4           MUL     AB
   \   000051   2C           ADD     A,R4
   \   000052   FB           MOV     R3,A
   \   000053   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000056   E0           MOVX    A,@DPTR
   \   000057   2A           ADD     A,R2
   \   000058   FA           MOV     R2,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   3B           ADDC    A,R3
   \   00005C   FB           MOV     R3,A
   \   00005D   740B         MOV     A,#0xb
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   E0           MOVX    A,@DPTR
   \   000063   FC           MOV     R4,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FD           MOV     R5,A
   \   000067   8A82         MOV     DPL,R2
   \   000069   8B83         MOV     DPH,R3
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6C           XRL     A,R4
   \   00006D   7003         JNZ     ??ZDSecMgrEntryLookup_3
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_3:
   \   000072   7012         JNZ     ??ZDSecMgrEntryLookup_4
    766                  {
    767                    // return successful results
    768                    *entry = &ZDSecMgrEntries[index];
   \   000074   EA           MOV     A,R2
   \   000075   F8           MOV     R0,A
   \   000076   EB           MOV     A,R3
   \   000077   F9           MOV     R1,A
   \   000078   8E82         MOV     DPL,R6
   \   00007A   8F83         MOV     DPH,R7
   \   00007C   12....       LCALL   ??Subroutine106_0 & 0xFFFF
    769                    status = ZSuccess;
   \                     ??CrossCallReturnLabel_168:
   \   00007F   75..00       MOV     ?V0 + 0,#0x0
    770          
    771                    // break from loop
    772                    index = ZDSECMGR_ENTRY_MAX;
   \   000082   7803         MOV     R0,#0x3
   \   000084   7900         MOV     R1,#0x0
    773                  }
    774                }
   \                     ??ZDSecMgrEntryLookup_4:
   \   000086   12....       LCALL   ?Subroutine46 & 0xFFFF
    775              }
    776            }
   \                     ??CrossCallReturnLabel_80:
   \   000089   40B5         JC      ??ZDSecMgrEntryLookup_2
    777          
    778            return status;
   \                     ??ZDSecMgrEntryLookup_1:
   \   00008B   A9..         MOV     R1,?V0 + 0
   \   00008D   02....       LJMP    ?Subroutine76 & 0xFFFF
    779          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000001                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                REQUIRE ?Subroutine71
   \   000001                ; // Fall through to label ?Subroutine71

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   740D         MOV     A,#0xd
   \   000002                REQUIRE ??Subroutine91_0
   \   000002                ; // Fall through to label ??Subroutine91_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine92_0
   \   000003                ; // Fall through to label ??Subroutine92_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine101_0
   \   000004                ; // Fall through to label ??Subroutine101_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000003   02....       LJMP    ?Subroutine73 & 0xFFFF
    780          
    781          /******************************************************************************
    782           * @fn          ZDSecMgrEntryLookupAMI
    783           *
    784           * @brief       Lookup entry using specified address index
    785           *
    786           * @param       ami   - [in] Address Manager index
    787           * @param       entry - [out] valid entry
    788           *
    789           * @return      ZStatus_t
    790           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    791          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    792          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    793            ZStatus_t status;
    794            uint16    index;
    795          
    796          
    797            // initialize results
    798            *entry = NULL;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   12....       LCALL   ?Subroutine15 & 0xFFFF
    799            status = ZNwkUnknownDevice;
    800          
    801            // verify data is available
    802            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_31:
   \   00000C   7002         JNZ     ??ZDSecMgrEntryLookupAMI_0
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000010   6036         JZ      ??ZDSecMgrEntryLookupAMI_1
    803            {
    804              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000012   7E00         MOV     R6,#0x0
   \   000014   7F00         MOV     R7,#0x0
    805              {
    806                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000016   8E..         MOV     ?V0 + 0,R6
   \   000018   8F..         MOV     ?V0 + 1,R7
   \   00001A   E5..         MOV     A,?V0 + 0
   \   00001C   75F01D       MOV     B,#0x1d
   \   00001F   A4           MUL     AB
   \   000020   F5..         MOV     ?V0 + 0,A
   \   000022   A8F0         MOV     R0,B
   \   000024   75F01D       MOV     B,#0x1d
   \   000027   E5..         MOV     A,?V0 + 1
   \   000029   A4           MUL     AB
   \   00002A   28           ADD     A,R0
   \   00002B   F5..         MOV     ?V0 + 1,A
   \   00002D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000030   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000033   7003         JNZ     ??ZDSecMgrEntryLookupAMI_3
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000038   7009         JNZ     ??ZDSecMgrEntryLookupAMI_4
    807                {
    808                  // return successful results
    809                  *entry = &ZDSecMgrEntries[index];
   \   00003A   12....       LCALL   ?Subroutine9 & 0xFFFF
    810                  status = ZSuccess;
   \                     ??CrossCallReturnLabel_225:
   \   00003D   7900         MOV     R1,#0x0
    811          
    812                  // break from loop
    813                  index = ZDSECMGR_ENTRY_MAX;
   \   00003F   7E03         MOV     R6,#0x3
   \   000041   7F00         MOV     R7,#0x0
    814                }
    815              }
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000043   12....       LCALL   ?Subroutine43 & 0xFFFF
    816            }
   \                     ??CrossCallReturnLabel_73:
   \   000046   40CE         JC      ??ZDSecMgrEntryLookupAMI_2
    817          
    818            return status;
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000048   02....       LJMP    ??Subroutine87_0 & 0xFFFF
    819          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   F0           MOVX    @DPTR,A
   \   000004   79C8         MOV     R1,#-0x38
   \   000006   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
    820          
    821          /******************************************************************************
    822           * @fn          ZDSecMgrEntryLookupExt
    823           *
    824           * @brief       Lookup entry index using specified EXT address.
    825           *
    826           * @param       extAddr - [in] EXT address
    827           * @param       entry   - [out] valid entry
    828           *
    829           * @return      ZStatus_t
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    832          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    833            ZStatus_t status;
    834            uint16    ami;
    835          
    836          
    837            // initialize results
    838            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    839            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    840          
    841            // lookup address index
    842            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   \   000027   7010         JNZ     ??ZDSecMgrEntryLookupExt_0
    843            {
    844              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000029                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000029   EE           MOV     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FD           MOV     R5,A
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   12....       LCALL   ?Subroutine35 & 0xFFFF
    845            }
   \                     ??CrossCallReturnLabel_59:
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
    846          
    847            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000039   02....       LJMP    ?Subroutine74 & 0xFFFF
    848          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002                REQUIRE ??Subroutine94_0
   \   000002                ; // Fall through to label ??Subroutine94_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine95_0
   \   000002                ; // Fall through to label ??Subroutine95_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000003   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000006   22           RET
    849          
    850          /******************************************************************************
    851           * @fn          ZDSecMgrEntryFree
    852           *
    853           * @brief       Free entry.
    854           *
    855           * @param       entry - [in] valid entry
    856           *
    857           * @return      ZStatus_t
    858           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    859          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
   \   000000   02....       LJMP    ?Subroutine70 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000007                REQUIRE ??Subroutine99_0
   \   000007                ; // Fall through to label ??Subroutine99_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine99_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine100_0
   \   000001                ; // Fall through to label ??Subroutine100_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine109_0
   \   000004                ; // Fall through to label ??Subroutine109_0
    860          {
    861            entry->ami = INVALID_NODE_ADDR;
    862          }
    863          
    864          /******************************************************************************
    865           * @fn          ZDSecMgrEntryNew
    866           *
    867           * @brief       Get a new entry.
    868           *
    869           * @param       entry - [out] valid entry
    870           *
    871           * @return      ZStatus_t
    872           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    874          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    875            ZStatus_t status;
    876            uint16    index;
    877          
    878          
    879            // initialize results
    880            *entry = NULL;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine15 & 0xFFFF
    881            status = ZNwkUnknownDevice;
    882          
    883            // verify data is available
    884            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_32:
   \   00000C   7002         JNZ     ??ZDSecMgrEntryNew_0
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryNew_0:
   \   000010   6059         JZ      ??ZDSecMgrEntryNew_1
    885            {
    886              // find available entry
    887              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000012   7E00         MOV     R6,#0x0
   \   000014   7F00         MOV     R7,#0x0
    888              {
    889                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_2:
   \   000016   EE           MOV     A,R6
   \   000017   FC           MOV     R4,A
   \   000018   EF           MOV     A,R7
   \   000019   FD           MOV     R5,A
   \   00001A   EC           MOV     A,R4
   \   00001B   75F01D       MOV     B,#0x1d
   \   00001E   A4           MUL     AB
   \   00001F   FC           MOV     R4,A
   \   000020   A8F0         MOV     R0,B
   \   000022   75F01D       MOV     B,#0x1d
   \   000025   ED           MOV     A,R5
   \   000026   A4           MUL     AB
   \   000027   28           ADD     A,R0
   \   000028   FD           MOV     R5,A
   \   000029   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   2C           ADD     A,R4
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   3D           ADDC    A,R5
   \   000033   F5..         MOV     ?V0 + 1,A
   \   000035   85..82       MOV     DPL,?V0 + 0
   \   000038   F583         MOV     DPH,A
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   64FE         XRL     A,#0xfe
   \   00003D   7004         JNZ     ??ZDSecMgrEntryNew_3
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrEntryNew_3:
   \   000043   7021         JNZ     ??ZDSecMgrEntryNew_4
    890                {
    891                  // return successful result
    892                  *entry = &ZDSecMgrEntries[index];
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   12....       LCALL   ??Subroutine112_0 & 0xFFFF
    893                  status = ZSuccess;
   \                     ??CrossCallReturnLabel_221:
   \   00004C   7900         MOV     R1,#0x0
    894          
    895                  // Set the authentication option to default
    896                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00004E   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2C           ADD     A,R4
   \   000053   FC           MOV     R4,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   3D           ADDC    A,R5
   \   000057   FD           MOV     R5,A
   \   000058   741C         MOV     A,#0x1c
   \   00005A   2C           ADD     A,R4
   \   00005B   F582         MOV     DPL,A
   \   00005D   E4           CLR     A
   \   00005E   3D           ADDC    A,R5
   \   00005F   F583         MOV     DPH,A
   \   000061   E4           CLR     A
   \   000062   F0           MOVX    @DPTR,A
    897          
    898                  // break from loop
    899                  index = ZDSECMGR_ENTRY_MAX;
   \   000063   7E03         MOV     R6,#0x3
   \   000065   FF           MOV     R7,A
    900                }
    901              }
   \                     ??ZDSecMgrEntryNew_4:
   \   000066   12....       LCALL   ?Subroutine43 & 0xFFFF
    902            }
   \                     ??CrossCallReturnLabel_74:
   \   000069   40AB         JC      ??ZDSecMgrEntryNew_2
    903          
    904            return status;
   \                     ??ZDSecMgrEntryNew_1:
   \   00006B   02....       LJMP    ??Subroutine87_0 & 0xFFFF
    905          }
    906          
    907          /******************************************************************************
    908           * @fn          ZDSecMgrCtrlInit
    909           *
    910           * @brief       Initialize control sub module
    911           *
    912           * @param       none
    913           *
    914           * @return      none
    915           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    916          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    917          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    918            uint16 size;
    919            uint16 index;
    920          
    921            // allocate entry data
    922            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    923          
    924            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV     R2,#0x15
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL   ?Subroutine13 & 0xFFFF
    925          
    926            // initialize data
    927            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_21:
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrCtrlInit_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlInit_0:
   \   000019   6028         JZ      ??ZDSecMgrCtrlInit_1
    928            {
    929              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    930              {
    931                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   ACF0         MOV     R4,B
   \   00002B   75F007       MOV     B,#0x7
   \   00002E   EB           MOV     A,R3
   \   00002F   A4           MUL     AB
   \   000030   2C           ADD     A,R4
   \   000031   FB           MOV     R3,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000035   12....       LCALL   ?Subroutine54 & 0xFFFF
    932              }
    933            }
   \                     ??CrossCallReturnLabel_92:
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E4           CLR     A
   \   00003E   12....       LCALL   ??Subroutine85_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000041   40DC         JC      ??ZDSecMgrCtrlInit_2
    934          }
   \                     ??ZDSecMgrCtrlInit_1:
   \   000043   02....       LJMP    ??Subroutine100_0 & 0xFFFF
    935          
    936          /******************************************************************************
    937           * @fn          ZDSecMgrCtrlRelease
    938           *
    939           * @brief       Release control data.
    940           *
    941           * @param       ctrl - [in] valid control data
    942           *
    943           * @return      none
    944           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    945          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    946          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    947            // should always be enough entry control data
    948            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   E4           CLR     A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   02....       LJMP    ??Subroutine99_0 & 0xFFFF
    949          }
    950          
    951          /******************************************************************************
    952           * @fn          ZDSecMgrCtrlLookup
    953           *
    954           * @brief       Lookup control data.
    955           *
    956           * @param       entry - [in] valid entry data
    957           * @param       ctrl  - [out] control data - NULL if not found
    958           *
    959           * @return      none
    960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    961          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    962          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    963            uint16 index;
    964          
    965          
    966            // initialize search results
    967            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    968          
    969            // verify data is available
    970            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrCtrlLookup_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000019   6058         JZ      ??ZDSecMgrCtrlLookup_1
    971            {
    972              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    973              {
    974                // make sure control data is in use
    975                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   85F0..       MOV     ?V0 + 0,B
   \   00002C   75F007       MOV     B,#0x7
   \   00002F   EB           MOV     A,R3
   \   000030   A4           MUL     AB
   \   000031   25..         ADD     A,?V0 + 0
   \   000033   FB           MOV     R3,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000037   E0           MOVX    A,@DPTR
   \   000038   2A           ADD     A,R2
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   3B           ADDC    A,R3
   \   00003D   FB           MOV     R3,A
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   6024         JZ      ??ZDSecMgrCtrlLookup_3
    976                {
    977                  // check for entry match
    978                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   00004A   8A82         MOV     DPL,R2
   \   00004C   8B83         MOV     DPH,R3
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F5..         MOV     ?V0 + 0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F5..         MOV     ?V0 + 1,A
   \   000055   EE           MOV     A,R6
   \   000056   65..         XRL     A,?V0 + 0
   \   000058   7003         JNZ     ??ZDSecMgrCtrlLookup_4
   \   00005A   EF           MOV     A,R7
   \   00005B   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   00005D   700F         JNZ     ??ZDSecMgrCtrlLookup_3
    979                  {
    980                    // return this control data
    981                    *ctrl = &ZDSecMgrCtrlData[index];
   \   00005F   EA           MOV     A,R2
   \   000060   F8           MOV     R0,A
   \   000061   EB           MOV     A,R3
   \   000062   F9           MOV     R1,A
   \   000063   8C82         MOV     DPL,R4
   \   000065   8D83         MOV     DPH,R5
   \   000067   12....       LCALL   ??Subroutine106_0 & 0xFFFF
    982          
    983                    // break from loop
    984                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_169:
   \   00006A   7803         MOV     R0,#0x3
   \   00006C   7900         MOV     R1,#0x0
    985                  }
    986                }
    987              }
   \                     ??ZDSecMgrCtrlLookup_3:
   \   00006E   12....       LCALL   ?Subroutine46 & 0xFFFF
    988            }
   \                     ??CrossCallReturnLabel_81:
   \   000071   40AC         JC      ??ZDSecMgrCtrlLookup_2
    989          }
   \                     ??ZDSecMgrCtrlLookup_1:
   \   000073   02....       LJMP    ??Subroutine92_0 & 0xFFFF
    990          
    991          /******************************************************************************
    992           * @fn          ZDSecMgrCtrlSet
    993           *
    994           * @brief       Set control data.
    995           *
    996           * @param       device - [in] valid device data
    997           * @param       entry  - [in] valid entry data
    998           * @param       ctrl   - [in] valid control data
    999           *
   1000           * @return      none
   1001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1002          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1003                                ZDSecMgrEntry_t*  entry,
   1004                                ZDSecMgrCtrl_t*   ctrl )
   1005          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine104_0 & 0xFFFF
   1006            // set control date
   1007            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_159:
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FE           MOV     R6,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FF           MOV     R7,A
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   EE           MOV     A,R6
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   EF           MOV     A,R7
   \   000024   12....       LCALL   ?Subroutine10 & 0xFFFF
   1008            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_100:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   F0           MOVX    @DPTR,A
   1009            ctrl->entry      = entry;
   \   000031   8882         MOV     DPL,R0
   \   000033   8983         MOV     DPH,R1
   \   000035   EC           MOV     A,R4
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   ED           MOV     A,R5
   \   000039   F0           MOVX    @DPTR,A
   1010            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   00003A   7401         MOV     A,#0x1
   \   00003C   8882         MOV     DPL,R0
   \   00003E   8983         MOV     DPH,R1
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   F0           MOVX    @DPTR,A
   1011            ctrl->cntr       = 0;
   \   000046   E4           CLR     A
   \   000047   8882         MOV     DPL,R0
   \   000049   8983         MOV     DPH,R1
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   12....       LCALL   ?Subroutine10 & 0xFFFF
   1012          
   1013            // set device pointer
   1014            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_101:
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1015          }
   \                     ??CrossCallReturnLabel_170:
   \   000059   02....       LJMP    ??Subroutine96_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ?Subroutine72
   \   000006                ; // Fall through to label ?Subroutine72

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000003   22           RET
   1016          
   1017          /******************************************************************************
   1018           * @fn          ZDSecMgrCtrlAdd
   1019           *
   1020           * @brief       Add control data.
   1021           *
   1022           * @param       device - [in] valid device data
   1023           * @param       entry  - [in] valid entry data
   1024           *
   1025           * @return      ZStatus_t
   1026           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1027          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1028          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   1029            ZStatus_t status;
   1030            uint16    index;
   1031          
   1032          
   1033            // initialize results
   1034            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
   1035          
   1036            // verify data is available
   1037            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7002         JNZ     ??ZDSecMgrCtrlAdd_0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlAdd_0:
   \   000017   6050         JZ      ??ZDSecMgrCtrlAdd_1
   1038            {
   1039              // look for an empty slot
   1040              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7B00         MOV     R3,#0x0
   1041              {
   1042                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_2:
   \   00001D   EA           MOV     A,R2
   \   00001E   FC           MOV     R4,A
   \   00001F   EB           MOV     A,R3
   \   000020   FD           MOV     R5,A
   \   000021   EC           MOV     A,R4
   \   000022   75F007       MOV     B,#0x7
   \   000025   A4           MUL     AB
   \   000026   FC           MOV     R4,A
   \   000027   A8F0         MOV     R0,B
   \   000029   75F007       MOV     B,#0x7
   \   00002C   ED           MOV     A,R5
   \   00002D   A4           MUL     AB
   \   00002E   28           ADD     A,R0
   \   00002F   FD           MOV     R5,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000033   E0           MOVX    A,@DPTR
   \   000034   2C           ADD     A,R4
   \   000035   F5..         MOV     ?V0 + 2,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   3D           ADDC    A,R5
   \   00003A   F5..         MOV     ?V0 + 3,A
   \   00003C   85..82       MOV     DPL,?V0 + 2
   \   00003F   F583         MOV     DPH,A
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   701B         JNZ     ??ZDSecMgrCtrlAdd_3
   1043                {
   1044                  // return successful results
   1045                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000049                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000049   78..         MOV     R0,#?V0 + 2
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   AC..         MOV     R4,?V0 + 0
   \   000050   AD..         MOV     R5,?V0 + 1
   \   000052   EE           MOV     A,R6
   \   000053   FA           MOV     R2,A
   \   000054   EF           MOV     A,R7
   \   000055   FB           MOV     R3,A
   \   000056   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   1046          
   1047                  status = ZSuccess;
   \   00005E   7900         MOV     R1,#0x0
   1048          
   1049                  // break from loop
   1050                  index = ZDSECMGR_CTRL_MAX;
   \   000060   7A03         MOV     R2,#0x3
   \   000062   7B00         MOV     R3,#0x0
   1051                }
   1052              }
   \                     ??ZDSecMgrCtrlAdd_3:
   \   000064   12....       LCALL   ?Subroutine45 & 0xFFFF
   1053            }
   \                     ??CrossCallReturnLabel_79:
   \   000067   40B4         JC      ??ZDSecMgrCtrlAdd_2
   1054          
   1055            return status;
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000069   02....       LJMP    ??Subroutine103_0 & 0xFFFF
   1056          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1057          
   1058          /******************************************************************************
   1059           * @fn          ZDSecMgrCtrlTerm
   1060           *
   1061           * @brief       Terminate device control.
   1062           *
   1063           * @param       entry - [in] valid entry data
   1064           *
   1065           * @return      none
   1066           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1067          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1068          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1069            ZDSecMgrCtrl_t* ctrl;
   1070          
   1071            // remove device from control data
   1072            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   12....       LCALL   ?Subroutine51 & 0xFFFF
   1073          
   1074            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_87:
   \   000016   7002         JNZ     ??ZDSecMgrCtrlTerm_0
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlTerm_0:
   \   00001A   6009         JZ      ??CrossCallReturnLabel_44
   1075            {
   1076              ZDSecMgrCtrlRelease ( ctrl );
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   12....       LCALL   ?Subroutine25 & 0xFFFF
   1077            }
   1078          }
   \                     ??CrossCallReturnLabel_44:
   \   000025   02....       LJMP    ?Subroutine80 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine110_0
   \   000002                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   1079          
   1080          /******************************************************************************
   1081           * @fn          ZDSecMgrCtrlReset
   1082           *
   1083           * @brief       Reset control data.
   1084           *
   1085           * @param       device - [in] valid device data
   1086           * @param       entry  - [in] valid entry data
   1087           *
   1088           * @return      ZStatus_t
   1089           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1090          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1091          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1092            ZStatus_t       status;
   1093            ZDSecMgrCtrl_t* ctrl;
   1094          
   1095          
   1096            // initialize results
   1097            status = ZNwkUnknownDevice;
   1098          
   1099            // look for a match for the entry
   1100            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ?Subroutine51 & 0xFFFF
   1101          
   1102            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_88:
   \   000023   7002         JNZ     ??ZDSecMgrCtrlReset_0
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlReset_0:
   \   000027   601D         JZ      ??ZDSecMgrCtrlReset_1
   1103            {
   1104              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000029                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000032   EE           MOV     A,R6
   \   000033   FC           MOV     R4,A
   \   000034   EF           MOV     A,R7
   \   000035   FD           MOV     R5,A
   \   000036   AA..         MOV     R2,?V0 + 0
   \   000038   AB..         MOV     R3,?V0 + 1
   \   00003A   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   1105          
   1106              status = ZSuccess;
   \   000042   7900         MOV     R1,#0x0
   \   000044   800B         SJMP    ??ZDSecMgrCtrlReset_2
   1107            }
   1108            else
   1109            {
   1110              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_1:
   \   000046                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   000046   EE           MOV     A,R6
   \   000047   FC           MOV     R4,A
   \   000048   EF           MOV     A,R7
   \   000049   FD           MOV     R5,A
   \   00004A   AA..         MOV     R2,?V0 + 0
   \   00004C   AB..         MOV     R3,?V0 + 1
   \   00004E   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   1111            }
   1112          
   1113            return status;
   \                     ??ZDSecMgrCtrlReset_2:
   \   000051                REQUIRE ?Subroutine83
   \   000051                ; // Fall through to label ?Subroutine83
   1114          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   7402         MOV     A,#0x2
   \   000002   02....       LJMP    ??Subroutine91_0 & 0xFFFF
   1115          
   1116          /******************************************************************************
   1117           * @fn          ZDSecMgrMasterKeyLoad
   1118           *
   1119           * @brief       Load the MASTER key for device with specified EXT
   1120           *              address.
   1121           *
   1122           * @param       extAddr - [in] EXT address of device
   1123           * @param       key     - [in] MASTER key shared with device
   1124           *
   1125           * @return      ZStatus_t
   1126           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1127          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1128          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1129            ZStatus_t status;
   1130            uint8*    loaded;
   1131            uint16    ami;
   1132          
   1133          
   1134            // set status based on policy
   1135            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 3,A
   1136          
   1137            if ( status == ZSuccess )
   \   00001E   7031         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1138            {
   1139              // get the address index
   1140              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000028   701D         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1141              {
   1142                // overwrite old key
   1143                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   00002A                ; Setup parameters for call to function osal_memcpy
   \   00002A   8E..         MOV     ?V0 + 0,R6
   \   00002C   8F..         MOV     ?V0 + 1,R7
   \   00002E   75..00       MOV     ?V0 + 2,#0x0
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000036   7C10         MOV     R4,#0x10
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7405         MOV     A,#0x5
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   1144              }
   \                     ??CrossCallReturnLabel_236:
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   800A         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1145              else
   1146              {
   1147                // store new key -- NULL will zero key
   1148                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   000047                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000047   EE           MOV     A,R6
   \   000048   FC           MOV     R4,A
   \   000049   EF           MOV     A,R7
   \   00004A   FD           MOV     R5,A
   \   00004B   12....       LCALL   ?Subroutine38 & 0xFFFF
   1149              }
   1150            }
   \                     ??CrossCallReturnLabel_64:
   \   00004E   E9           MOV     A,R1
   \   00004F   F5..         MOV     ?V0 + 3,A
   1151          
   1152            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000051   A9..         MOV     R1,?V0 + 3
   \   000053   02....       LJMP    ?Subroutine77 & 0xFFFF
   1153          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00000D   E9           MOV     A,R1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   7404         MOV     A,#0x4
   \   000002                REQUIRE ??Subroutine102_0
   \   000002                ; // Fall through to label ??Subroutine102_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine103_0
   \   000003                ; // Fall through to label ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000009   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000006   22           RET
   1154          
   1155          /******************************************************************************
   1156           * @fn          ZDSecMgrAppKeyGet
   1157           *
   1158           * @brief       get an APP key - option APP(MASTER or LINK) key
   1159           *
   1160           * @param       initNwkAddr - [in] NWK address of initiator device
   1161           * @param       initExtAddr - [in] EXT address of initiator device
   1162           * @param       partNwkAddr - [in] NWK address of partner device
   1163           * @param       partExtAddr - [in] EXT address of partner device
   1164           * @param       key         - [out] APP(MASTER or LINK) key
   1165           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1166           *
   1167           * @return      ZStatus_t
   1168           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1169          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1170                                                           // to KEY_TYPE_APP_LINK since
   1171                                                           // only specific requirement
   1172                                                           // right now comes from SE profile
   1173          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1174          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1175                                       uint8*  initExtAddr,
   1176                                       uint16  partNwkAddr,
   1177                                       uint8*  partExtAddr,
   1178                                       uint8** key,
   1179                                       uint8*  keyType )
   1180          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740D         MOV     A,#0xd
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00000D   FA           MOV     R2,A
   \   00000E   E9           MOV     A,R1
   \   00000F   FB           MOV     R3,A
   \   000010   740F         MOV     A,#0xf
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000018   FE           MOV     R6,A
   \   000019   E9           MOV     A,R1
   \   00001A   FF           MOV     R7,A
   1181            // Intentionally unreferenced parameters
   1182            (void)initNwkAddr;
   1183            (void)initExtAddr;
   1184            (void)partNwkAddr;
   1185            (void)partExtAddr;
   1186            
   1187            //---------------------------------------------------------------------------
   1188            // note:
   1189            // should use a robust mechanism to generate keys, for example
   1190            // combine EXT addresses and call a hash function
   1191            //---------------------------------------------------------------------------
   1192            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   00001B                ; Setup parameters for call to function SSP_GetTrueRand
   \   00001B   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   00001E   7910         MOV     R1,#0x10
   \   000020   12....       LCALL   ??SSP_GetTrueRand?relay
   1193          
   1194            *keyType = ZDSecMgrAppKeyType;
   \   000023   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000026   E0           MOVX    A,@DPTR
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   F0           MOVX    @DPTR,A
   1195          
   1196            return ZSuccess;
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   02....       LJMP    ??Subroutine96_0 & 0xFFFF
   1197          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine97_0
   \   000004                ; // Fall through to label ??Subroutine97_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine97_0:
   \   000000   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003   22           RET
   1198          
   1199          /******************************************************************************
   1200           * @fn          ZDSecMgrAppKeyReq
   1201           *
   1202           * @brief       Process request for APP key between two devices.
   1203           *
   1204           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1205           *
   1206           * @return      none
   1207           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1208          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1209          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   1210            APSME_TransportKeyReq_t req;
   1211            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1212            uint16                  partNwkAddr;
   1213            uint8                   key[SEC_KEY_LEN];
   1214          
   1215          
   1216            // validate initiator and partner
   1217            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1218                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EA           MOV     A,R2
   \   00000F   2405         ADD     A,#0x5
   \   000011   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000014   6003         JZ      $+5
   \   000016   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000019   E5..         MOV     A,?V0 + 0
   \   00001B   2402         ADD     A,#0x2
   \   00001D   F8           MOV     R0,A
   \   00001E   E5..         MOV     A,?V0 + 1
   \   000020   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000023                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000023   740F         MOV     A,#0xf
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   \   00002C   8882         MOV     DPL,R0
   \   00002E   8983         MOV     DPH,R1
   \   000030   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000033   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   000036   E9           MOV     A,R1
   \   000037   6401         XRL     A,#0x1
   \   000039   6003         JZ      $+5
   \   00003B   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1219            {
   1220              // point the key to some memory
   1221              req.key = key;
   \   00003E   7417         MOV     A,#0x17
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   A882         MOV     R0,DPL
   \   000045   A983         MOV     R1,DPH
   \   000047   7406         MOV     A,#0x6
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1222          
   1223              // get an APP key - option APP (MASTER or LINK) key
   1224              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1225                                      initExtAddr,
   1226                                      partNwkAddr,
   1227                                      ind->partExtAddr,
   1228                                      &req.key,
   1229                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_171:
   \   00004F                ; Setup parameters for call to function SSP_GetTrueRand
   \   00004F   7417         MOV     A,#0x17
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   AA82         MOV     R2,DPL
   \   000056   AB83         MOV     R3,DPH
   \   000058   7910         MOV     R1,#0x10
   \   00005A   12....       LCALL   ??SSP_GetTrueRand?relay
   \   00005D   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000060   E0           MOVX    A,@DPTR
   \   000061   C0E0         PUSH    A
   \   000063   7404         MOV     A,#0x4
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   D0E0         POP     A
   \   00006A   F0           MOVX    @DPTR,A
   1230              {
   1231                // always secure
   1232                req.nwkSecure = TRUE;
   \   00006B   740C         MOV     A,#0xc
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   7401         MOV     A,#0x1
   \   000072   F0           MOVX    @DPTR,A
   1233                req.apsSecure = TRUE;
   \   000073   740B         MOV     A,#0xb
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   7401         MOV     A,#0x1
   \   00007A   F0           MOVX    @DPTR,A
   1234                req.tunnel    = NULL;
   \   00007B   740D         MOV     A,#0xd
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   E4           CLR     A
   \   000081   F0           MOVX    @DPTR,A
   \   000082   A3           INC     DPTR
   \   000083   12....       LCALL   ?Subroutine6 & 0xFFFF
   1235          
   1236                // send key to initiator device
   1237                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_9:
   \   000086   F8           MOV     R0,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F9           MOV     R1,A
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1238                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_172:
   \   000092   7408         MOV     A,#0x8
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   EE           MOV     A,R6
   \   000098   F0           MOVX    @DPTR,A
   \   000099   A3           INC     DPTR
   \   00009A   EF           MOV     A,R7
   \   00009B   F0           MOVX    @DPTR,A
   1239                req.initiator = TRUE;
   \   00009C   740A         MOV     A,#0xa
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   7401         MOV     A,#0x1
   \   0000A3   F0           MOVX    @DPTR,A
   1240                APSME_TransportKeyReq( &req );
   \   0000A4                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000A4   7402         MOV     A,#0x2
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   AA82         MOV     R2,DPL
   \   0000AB   AB83         MOV     R3,DPH
   \   0000AD   12....       LCALL   ??APSME_TransportKeyReq?relay
   1241          
   1242                // send key to partner device
   1243                req.dstAddr   = partNwkAddr;
   \   0000B0   85..82       MOV     DPL,?XSP + 0
   \   0000B3   85..83       MOV     DPH,?XSP + 1
   \   0000B6   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1244                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_173:
   \   0000BF   740F         MOV     A,#0xf
   \   0000C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C4   A882         MOV     R0,DPL
   \   0000C6   A983         MOV     R1,DPH
   \   0000C8   7408         MOV     A,#0x8
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1245                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_199:
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   E4           CLR     A
   \   0000D4   F0           MOVX    @DPTR,A
   1246          
   1247                APSME_TransportKeyReq( &req );
   \   0000D5                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   AA82         MOV     R2,DPL
   \   0000DC   AB83         MOV     R3,DPH
   \   0000DE   12....       LCALL   ??APSME_TransportKeyReq?relay
   1248              }
   1249            }
   1250          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000E1   7427         MOV     A,#0x27
   \   0000E3   02....       LJMP    ??Subroutine91_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003   88..         MOV     ?V0 + 0,R0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV     A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   FE           MOV     R6,A
   \   000001   EB           MOV     A,R3
   \   000002   3400         ADDC    A,#0x0
   \   000004   FF           MOV     R7,A
   \   000005                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000005                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   AC82         MOV     R4,DPL
   \   00000D   AD83         MOV     R5,DPH
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000016   E9           MOV     A,R1
   \   000017   6401         XRL     A,#0x1
   \   000019   22           RET
   1251          
   1252          /******************************************************************************
   1253           * @fn          ZDSecMgrEstablishKey
   1254           *
   1255           * @brief       Start SKKE with device joining network.
   1256           *
   1257           * @param       device - [in] ZDSecMgrDevice_t, device info
   1258           *
   1259           * @return      ZStatus_t
   1260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1261          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1262          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1263            ZStatus_t               status;
   1264            APSME_EstablishKeyReq_t req;
   1265          
   1266          
   1267            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1268            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_174:
   \   00001D   7404         MOV     A,#0x4
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   1269          
   1270            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000024                ; Setup parameters for call to function NLME_GetShortAddr
   \   000024   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000027   7002         JNZ     ??ZDSecMgrEstablishKey_0
   \   000029   EB           MOV     A,R3
   \   00002A   69           XRL     A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   00002B   7017         JNZ     ??ZDSecMgrEstablishKey_1
   1271            {
   1272              req.dstAddr   = device->nwkAddr;
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   12....       LCALL   ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000034   12....       LCALL   ?Subroutine16 & 0xFFFF
   1273              //devtag.0604.todo - remove obsolete
   1274              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_117:
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E4           CLR     A
   \   00003B   F0           MOVX    @DPTR,A
   1275              req.nwkSecure = FALSE;
   \   00003C   7406         MOV     A,#0x6
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E4           CLR     A
   \   000042   8010         SJMP    ??ZDSecMgrEstablishKey_2
   1276            }
   1277            else
   1278            {
   1279              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000044   12....       LCALL   ?Subroutine16 & 0xFFFF
   1280              //devtag.0604.todo - remove obsolete
   1281              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_118:
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   7401         MOV     A,#0x1
   \   00004C   F0           MOVX    @DPTR,A
   1282              req.nwkSecure = TRUE;
   \   00004D   7406         MOV     A,#0x6
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   7401         MOV     A,#0x1
   1283            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000054   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   1284          
   1285            status = APSME_EstablishKeyReq( &req );
   1286          
   1287            return status;
   \                     ??CrossCallReturnLabel_141:
   \   000057   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   00005A   7407         MOV     A,#0x7
   \   00005C   02....       LJMP    ??Subroutine91_0 & 0xFFFF
   1288          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B                REQUIRE ??Subroutine88_0
   \   00000B                ; // Fall through to label ??Subroutine88_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000003   EA           MOV     A,R2
   \   000004   68           XRL     A,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine89_0
   \   000006                ; // Fall through to label ??Subroutine89_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV     A,#0x5
   \   000005   22           RET
   1289          
   1290          /******************************************************************************
   1291           * @fn          ZDSecMgrSendMasterKey
   1292           *
   1293           * @brief       Send MASTER key to device joining network.
   1294           *
   1295           * @param       device - [in] ZDSecMgrDevice_t, device info
   1296           *
   1297           * @return      ZStatus_t
   1298           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1299          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1300          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1301            ZStatus_t               status;
   1302            APSME_TransportKeyReq_t req;
   1303          
   1304          
   1305            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   12....       LCALL   ?Subroutine5 & 0xFFFF
   1306            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1307            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_175:
   \   00001D   740B         MOV     A,#0xb
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   F0           MOVX    @DPTR,A
   1308          
   1309            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000026                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   AC82         MOV     R4,DPL
   \   00002D   AD83         MOV     R5,DPH
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00003E   F583         MOV     DPH,A
   \   000040   8882         MOV     DPL,R0
   \   000042   12....       LCALL   ?Subroutine39 & 0xFFFF
   1310          
   1311            //check if using secure hop to to parent
   1312            if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_66:
   \   000045                ; Setup parameters for call to function NLME_GetShortAddr
   \   000045   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000048   7002         JNZ     ??ZDSecMgrSendMasterKey_0
   \   00004A   EB           MOV     A,R3
   \   00004B   69           XRL     A,R1
   \                     ??ZDSecMgrSendMasterKey_0:
   \   00004C   6012         JZ      ??ZDSecMgrSendMasterKey_1
   1313            {
   1314              //send to parent with security
   1315              req.dstAddr   = device->parentAddr;
   \   00004E   12....       LCALL   ?Subroutine3 & 0xFFFF
   1316              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_197:
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   7401         MOV     A,#0x1
   \   000056   F0           MOVX    @DPTR,A
   1317              req.apsSecure = TRUE;
   \   000057   7409         MOV     A,#0x9
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   7401         MOV     A,#0x1
   \   00005E   8015         SJMP    ??ZDSecMgrSendMasterKey_2
   1318            }
   1319            else
   1320            {
   1321              //direct with no security
   1322              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   12....       LCALL   ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000067   12....       LCALL   ?Subroutine3 & 0xFFFF
   1323              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_198:
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E4           CLR     A
   \   00006E   F0           MOVX    @DPTR,A
   1324              req.apsSecure = FALSE;
   \   00006F   7409         MOV     A,#0x9
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E4           CLR     A
   1325            }
   \                     ??ZDSecMgrSendMasterKey_2:
   \   000075   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   1326          
   1327            status = APSME_TransportKeyReq( &req );
   1328          
   1329            return status;
   \                     ??CrossCallReturnLabel_142:
   \   000078   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00007B   02....       LJMP    ?Subroutine76 & 0xFFFF
   1330          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   000008   7406         MOV     A,#0x6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine107_0
   \   000002                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine108_0
   \   000006                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
   1331          
   1332          /******************************************************************************
   1333           * @fn          ZDSecMgrSendNwkKey
   1334           *
   1335           * @brief       Send NWK key to device joining network.
   1336           *
   1337           * @param       device - [in] ZDSecMgrDevice_t, device info
   1338           *
   1339           * @return      ZStatus_t
   1340           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1341          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1342          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1343            ZStatus_t               status;
   1344            APSME_TransportKeyReq_t req;
   1345            APSDE_FrameTunnel_t     tunnel;
   1346          
   1347            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000015   E8           MOV     A,R0
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   E9           MOV     A,R1
   \   000019   12....       LCALL   ?Subroutine5 & 0xFFFF
   1348            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_8:
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine93_0 & 0xFFFF
   1349          
   1350            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1351              req.keyType   = KEY_TYPE_NWK_HIGH;
   1352            else
   1353              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_125:
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7401         MOV     A,#0x1
   \   000027   F0           MOVX    @DPTR,A
   1354          
   1355            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1356                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1357            {
   1358              // set values
   1359              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1360              req.key       = _NIB.nwkActiveKey.key;
   1361              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1362              //key isn't used to secure the frame at the APS layer -- since the receiving
   1363              //device may not have a NWK key yet
   1364              req.apsSecure = TRUE;
   1365          
   1366              // check if using secure hop to to parent
   1367              if ( device->parentAddr == NLME_GetShortAddr() )
   1368              {
   1369                req.nwkSecure = FALSE;
   1370                req.tunnel    = NULL;
   1371              }
   1372              else
   1373              {
   1374                req.nwkSecure   = TRUE;
   1375                req.tunnel      = &tunnel;
   1376                req.tunnel->tna = device->parentAddr;
   1377                req.tunnel->dea = device->extAddr;
   1378              }
   1379            }
   1380            else
   1381            {
   1382              // default values
   1383              //devtag.0604.verify
   1384              req.nwkSecure = TRUE;
   \   000028   740A         MOV     A,#0xa
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   7401         MOV     A,#0x1
   \   00002F   F0           MOVX    @DPTR,A
   1385              req.apsSecure = FALSE;
   \   000030   7409         MOV     A,#0x9
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   1386              req.tunnel    = NULL;
   \   000037   740B         MOV     A,#0xb
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
   1387          
   1388              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000040                ; Setup parameters for call to function NLME_GetShortAddr
   \   000040   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000043   EE           MOV     A,R6
   \   000044   2404         ADD     A,#0x4
   \   000046   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000049   8882         MOV     DPL,R0
   \   00004B   F583         MOV     DPH,A
   \   00004D   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000050   7002         JNZ     ??ZDSecMgrSendNwkKey_0
   \   000052   EB           MOV     A,R3
   \   000053   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000054   6003         JZ      ??CrossCallReturnLabel_182
   1389              {
   1390                req.dstAddr = device->parentAddr;
   \   000056   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   1391              }
   1392          
   1393              // special cases
   1394              //devtag.0604.todo - modify to preconfig flag
   1395              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_182:
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   7038         JNZ     ??ZDSecMgrSendNwkKey_1
   1396              {
   1397                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   000066   90....       MOV     DPTR,#(_NIB + 62)
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   C0E0         PUSH    A
   \   00006C   7403         MOV     A,#0x3
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   D0E0         POP     A
   \   000073   F0           MOVX    @DPTR,A
   1398                req.key       = _NIB.nwkActiveKey.key;
   \   000074   7404         MOV     A,#0x4
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   74..         MOV     A,#((_NIB + 63) & 0xff)
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   74..         MOV     A,#(((_NIB + 63) >> 8) & 0xff)
   \   00007F   F0           MOVX    @DPTR,A
   1399          
   1400                // check if using secure hop to to parent
   1401                if ( device->parentAddr == NLME_GetShortAddr() )
   \   000080                ; Setup parameters for call to function NLME_GetShortAddr
   \   000080   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000083   8A..         MOV     ?V0 + 2,R2
   \   000085   8B..         MOV     ?V0 + 3,R3
   \   000087   A8..         MOV     R0,?V0 + 2
   \   000089   A9..         MOV     R1,?V0 + 3
   \   00008B   85..82       MOV     DPL,?V0 + 0
   \   00008E   85..83       MOV     DPH,?V0 + 1
   \   000091   E0           MOVX    A,@DPTR
   \   000092   68           XRL     A,R0
   \   000093   7003         JNZ     ??ZDSecMgrSendNwkKey_2
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_2:
   \   000098   7014         JNZ     ??ZDSecMgrSendNwkKey_3
   1402                {
   1403                  req.nwkSecure = FALSE;
   \   00009A   740A         MOV     A,#0xa
   \   00009C   800B         SJMP    ??ZDSecMgrSendNwkKey_4
   1404                }
   1405              }
   1406              else
   1407              {
   1408                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_1:
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   E4           CLR     A
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   F0           MOVX    @DPTR,A
   1409                req.keySeqNum = 0;
   \   0000A7   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   E4           CLR     A
   \   0000AD   F0           MOVX    @DPTR,A
   1410              }
   1411            }
   1412          
   1413            status = APSME_TransportKeyReq( &req );
   1414          
   1415            return status;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000AE                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000AE   85..82       MOV     DPL,?XSP + 0
   \   0000B1   85..83       MOV     DPH,?XSP + 1
   \   0000B4   AA82         MOV     R2,DPL
   \   0000B6   AB83         MOV     R3,DPH
   \   0000B8   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000BB   740D         MOV     A,#0xd
   \   0000BD   02....       LJMP    ??Subroutine102_0 & 0xFFFF
   1416          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   F8           MOV     R0,A
   \   000001   EF           MOV     A,R7
   \   000002                REQUIRE ??Subroutine90_0
   \   000002                ; // Fall through to label ??Subroutine90_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine106_0
   \   000006                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000003   02....       LJMP    ?Subroutine71 & 0xFFFF
   1417          
   1418          /******************************************************************************
   1419           * @fn          ZDSecMgrDeviceEntryRemove
   1420           *
   1421           * @brief       Remove device entry.
   1422           *
   1423           * @param       entry - [in] valid entry
   1424           *
   1425           * @return      none
   1426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1427          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   \   000000   02....       LJMP    ?Subroutine70 & 0xFFFF
   1428          {
   1429            // terminate device control
   1430            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1431            {
   1432              ZDSecMgrCtrlTerm( entry );
   1433            }
   1434          
   1435            // remove device from entry data
   1436            ZDSecMgrEntryFree( entry );
   1437          
   1438            // remove EXT address
   1439            //ZDSecMgrExtAddrRelease( aiOld );
   1440          }
   1441          
   1442          /******************************************************************************
   1443           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1444           *
   1445           * @brief       Remove device entry by its ext address.
   1446           *
   1447           * @param       pAddr - pointer to the extended address
   1448           *
   1449           * @return      ZStatus_t
   1450           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1451          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1452          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1453            ZDSecMgrEntry_t *pEntry;
   1454            uint8           retValue;
   1455            
   1456            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   000009                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000016   E9           MOV     A,R1
   1457            
   1458            if( retValue == ZSuccess )
   \   000017   7007         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
   1459            {
   1460              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000019   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   00001C   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   00001F   F0           MOVX    @DPTR,A
   1461            }
   1462            
   1463            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000020   02....       LJMP    ?Subroutine80 & 0xFFFF
   1464          }
   1465          
   1466          /******************************************************************************
   1467           * @fn          ZDSecMgrDeviceEntryAdd
   1468           *
   1469           * @brief       Add entry.
   1470           *
   1471           * @param       device - [in] ZDSecMgrDevice_t, device info
   1472           * @param       ami    - [in] Address Manager index
   1473           *
   1474           * @return      ZStatus_t
   1475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1476          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1477          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1478            AddrMgrEntry_t entry;
   1479          
   1480            // get the ami data
   1481            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   7402         MOV     A,#0x2
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
   1482            entry.index = ami;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine1 & 0xFFFF
   1483          
   1484            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_140:
   \   00001F   12....       LCALL   ??AddrMgrEntryGet?relay
   1485          
   1486            // check if NWK address is same
   1487            if ( entry.nwkAddr != nwkAddr )
   \   000022   7401         MOV     A,#0x1
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6E           XRL     A,R6
   \   000029   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002E   600F         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1488            {
   1489              // update NWK address
   1490              entry.nwkAddr = nwkAddr;
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EE           MOV     A,R6
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EF           MOV     A,R7
   \   000039   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   1491          
   1492              AddrMgrEntryUpdate( &entry );
   1493            }
   \                     ??CrossCallReturnLabel_143:
   \   00003C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   1494          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00003F   02....       LJMP    ?Subroutine81 & 0xFFFF
   1495          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine87_0
   \   000003                ; // Fall through to label ??Subroutine87_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1496          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1497          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1498            ZStatus_t        status;
   1499            ZDSecMgrEntry_t* entry;
   1500          
   1501          
   1502            // initialize as unknown until completion
   1503            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 2,#-0x38
   1504          
   1505            device->ctrl = NULL;
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   12....       LCALL   ?Subroutine11 & 0xFFFF
   1506          
   1507            // make sure not already registered
   1508            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_14:
   \   000027   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   00002A   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   00002D   E9           MOV     A,R1
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   7034         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1509            {
   1510              // verify that address index is same
   1511              if ( entry->ami != ami )
   \   000036   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6E           XRL     A,R6
   \   00003B   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000040   6036         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1512              {
   1513                // remove conflicting entry
   1514                ZDSecMgrDeviceEntryRemove( entry );
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F583         MOV     DPH,A
   \   00004C   8882         MOV     DPL,R0
   \   00004E   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000051   12....       LCALL   ?Subroutine11 & 0xFFFF
   1515          
   1516                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_15:
   \   000054   EE           MOV     A,R6
   \   000055   FA           MOV     R2,A
   \   000056   EF           MOV     A,R7
   \   000057   FB           MOV     R3,A
   \   000058   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   00005B   E9           MOV     A,R1
   \   00005C   701A         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1517                {
   1518                  // update NWK address
   1519                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   00005E                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00005E   85..82       MOV     DPL,?V0 + 0
   \   000061   85..83       MOV     DPH,?V0 + 1
   \   000064   E0           MOVX    A,@DPTR
   \   000065   12....       LCALL   ?Subroutine33 & 0xFFFF
   1520                }
   1521              }
   1522            }
   \                     ??CrossCallReturnLabel_55:
   \   000068   800E         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1523            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   00006A                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00006A   AC82         MOV     R4,DPL
   \   00006C   AD83         MOV     R5,DPH
   \   00006E   EE           MOV     A,R6
   \   00006F   FA           MOV     R2,A
   \   000070   EF           MOV     A,R7
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000075   E9           MOV     A,R1
   \   000076   60E6         JZ      ??ZDSecMgrDeviceEntryAdd_3
   1524            {
   1525              // update NWK address
   1526              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1527            }
   1528          
   1529            // check if a new entry needs to be created
   1530            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   000078   85..82       MOV     DPL,?XSP + 0
   \   00007B   85..83       MOV     DPH,?XSP + 1
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   7002         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000083   701D         JNZ     ??CrossCallReturnLabel_56
   1531            {
   1532              // get new entry
   1533              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000085                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000085   85..82       MOV     DPL,?XSP + 0
   \   000088   85..83       MOV     DPH,?XSP + 1
   \   00008B   AA82         MOV     R2,DPL
   \   00008D   AB83         MOV     R3,DPH
   \   00008F   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000092   E9           MOV     A,R1
   \   000093   7010         JNZ     ??ZDSecMgrDeviceEntryAdd_5
   1534              {
   1535                // reset entry lkd
   1536          
   1537                // finish setting up entry
   1538                entry->ami = ami;
   \   000095   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000098   EE           MOV     A,R6
   \   000099   F0           MOVX    @DPTR,A
   \   00009A   A3           INC     DPTR
   \   00009B   EF           MOV     A,R7
   \   00009C   12....       LCALL   ?Subroutine6 & 0xFFFF
   1539          
   1540                // update NWK address
   1541                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??CrossCallReturnLabel_10:
   \   00009F   12....       LCALL   ?Subroutine33 & 0xFFFF
   1542          
   1543                // enter new device into device control
   1544                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1545                {
   1546                  status = ZDSecMgrCtrlAdd( device, entry );
   1547                }
   1548                else
   1549                {
   1550                  status = ZSuccess;
   1551                }
   1552              }
   1553            }
   1554            else
   1555            {
   1556              // reset entry lkd
   1557          
   1558              // reset entry in entry control
   1559              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1560              {
   1561                status = ZDSecMgrCtrlReset( device, entry );
   1562              }
   1563              else
   1564              {
   1565                status = ZSuccess;
   \                     ??CrossCallReturnLabel_56:
   \   0000A2   75..00       MOV     ?V0 + 2,#0x0
   1566              }
   1567            }
   1568          
   1569            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   0000A5   A9..         MOV     R1,?V0 + 2
   \   0000A7   7402         MOV     A,#0x2
   \   0000A9   02....       LJMP    ?Subroutine75 & 0xFFFF
   1570          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   FC           MOV     R4,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   FD           MOV     R5,A
   \   000004   EE           MOV     A,R6
   \   000005   FA           MOV     R2,A
   \   000006   EF           MOV     A,R7
   \   000007   FB           MOV     R3,A
   \   000008   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   AC82         MOV     R4,DPL
   \   000005   AD83         MOV     R5,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine113_0
   \   000006                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000003   22           RET
   1571          
   1572          /******************************************************************************
   1573           * @fn          ZDSecMgrDeviceCtrlHandler
   1574           *
   1575           * @brief       Device control handler.
   1576           *
   1577           * @param       device - [in] ZDSecMgrDevice_t, device info
   1578           *
   1579           * @return      none
   1580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1581          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1582          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1583            uint8 state;
   1584            uint8 cntr;
   1585          
   1586          
   1587            state = device->ctrl->state;
   \   000005   EA           MOV     A,R2
   \   000006   2408         ADD     A,#0x8
   \   000008   F8           MOV     R0,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F9           MOV     R1,A
   \   00000D   E8           MOV     A,R0
   \   00000E   FE           MOV     R6,A
   \   00000F   E9           MOV     A,R1
   \   000010   FF           MOV     R7,A
   \   000011   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 0,A
   1588            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1589          
   1590            switch ( state )
   \   000017   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for ZDSecMgrDeviceCtrlHandler>_0`:
   \   00001A   02           DB        2
   \   00001B   05           DB        5
   \   00001C   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   00001E   ....         DW        ??ZDSecMgrDeviceCtrlHandler_1
   \   000020   ....         DW        ??ZDSecMgrDeviceCtrlHandler_2
   \   000022   ....         DW        ??ZDSecMgrDeviceCtrlHandler_3
   \   000024   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   000026   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   000028   ....         DW        ??ZDSecMgrDeviceCtrlHandler_4
   1591            {
   1592              case ZDSECMGR_CTRL_TK_MASTER:
   1593                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00002A                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   00002A   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   00002D   E9           MOV     A,R1
   \   00002E   7016         JNZ     ??ZDSecMgrDeviceCtrlHandler_3
   1594                {
   1595                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000030   75..03       MOV     ?V0 + 0,#0x3
   1596                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   000033   8015         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1597                }
   1598                break;
   1599          
   1600              case ZDSECMGR_CTRL_SKKE_INIT:
   1601                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000035                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   000035   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   000038   E9           MOV     A,R1
   \   000039   700B         JNZ     ??ZDSecMgrDeviceCtrlHandler_3
   1602                {
   1603                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   00003B   75..04       MOV     ?V0 + 0,#0x4
   \   00003E   800A         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1604                }
   1605                break;
   1606          
   1607              case ZDSECMGR_CTRL_SKKE_WAIT:
   1608                // continue to wait for SKA control timeout
   1609                break;
   1610          
   1611              case ZDSECMGR_CTRL_TK_NWK:
   1612                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000040                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000040   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000043   E9           MOV     A,R1
   \   000044   6022         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   1613                {
   1614                  state = ZDSECMGR_CTRL_NONE;
   1615                }
   1616                break;
   1617          
   1618              default:
   1619                state = ZDSECMGR_CTRL_NONE;
   1620                break;
   1621            }
   1622          
   1623            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000046   E5..         MOV     A,?V0 + 0
   \   000048   601E         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   1624            {
   1625              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   00004A   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00004D   E5..         MOV     A,?V0 + 0
   \   00004F   F0           MOVX    @DPTR,A
   1626              device->ctrl->cntr  = cntr;
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   12....       LCALL   ?Subroutine23 & 0xFFFF
   1627          
   1628              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \                     ??CrossCallReturnLabel_39:
   \   000057                ; Setup parameters for call to function osal_start_timerEx
   \   000057   7C64         MOV     R4,#0x64
   \   000059   7D00         MOV     R5,#0x0
   \   00005B   7A00         MOV     R2,#0x0
   \   00005D   FB           MOV     R3,A
   \   00005E   90....       MOV     DPTR,#ZDAppTaskID
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F9           MOV     R1,A
   \   000063   12....       LCALL   ??osal_start_timerEx?relay
   \   000066   8007         SJMP    ??CrossCallReturnLabel_45
   1629            }
   1630            else
   1631            {
   1632              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000068   8E82         MOV     DPL,R6
   \   00006A   8F83         MOV     DPH,R7
   \   00006C   12....       LCALL   ?Subroutine25 & 0xFFFF
   1633            }
   1634          }
   \                     ??CrossCallReturnLabel_45:
   \   00006F   02....       LJMP    ??Subroutine96_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000003   02....       LJMP    ?Subroutine72 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000003   A3           INC     DPTR
   \   000004   7401         MOV     A,#0x1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET
   1635          
   1636          /******************************************************************************
   1637           * @fn          ZDSecMgrDeviceCtrlSetup
   1638           *
   1639           * @brief       Setup device control.
   1640           *
   1641           * @param       device - [in] ZDSecMgrDevice_t, device info
   1642           *
   1643           * @return      ZStatus_t
   1644           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1645          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1646          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1647            if ( device->ctrl != NULL )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000013   7001         JNZ     ??ZDSecMgrDeviceCtrlSetup_0
   \   000015   E9           MOV     A,R1
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   000016   6023         JZ      ??ZDSecMgrDeviceCtrlSetup_1
   1648            {
   1649              if ( device->secure == FALSE )
   \   000018   E8           MOV     A,R0
   \   000019   2405         ADD     A,#0x5
   \   00001B   F8           MOV     R0,A
   \   00001C   E9           MOV     A,R1
   \   00001D   3400         ADDC    A,#0x0
   \   00001F   F9           MOV     R1,A
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   7004         JNZ     ??ZDSecMgrDeviceCtrlSetup_2
   1650              {
   1651                // send the master key data to the joining device
   1652                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002D   7402         MOV     A,#0x2
   \   00002F   8002         SJMP    ??ZDSecMgrDeviceCtrlSetup_3
   1653              }
   1654              else
   1655              {
   1656                // start SKKE
   1657                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000031   7403         MOV     A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_3:
   \   000033   8882         MOV     DPL,R0
   \   000035   8983         MOV     DPH,R1
   \   000037   F0           MOVX    @DPTR,A
   1658              }
   1659          
   1660              ZDSecMgrDeviceCtrlHandler( device );
   \   000038                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000038   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1661            }
   1662          }
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   00003B   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   1663          
   1664          /******************************************************************************
   1665           * @fn          ZDSecMgrDeviceCtrlUpdate
   1666           *
   1667           * @brief       Update control data.
   1668           *
   1669           * @param       extAddr - [in] EXT address
   1670           * @param       state   - [in] new control state
   1671           *
   1672           * @return      none
   1673           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1674          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1675          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1676            ZDSecMgrEntry_t* entry;
   1677            ZDSecMgrCtrl_t*  ctrl;
   1678          
   1679          
   1680            // lookup device entry data
   1681            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV     A,#0x2
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   AC82         MOV     R4,DPL
   \   000013   AD83         MOV     R5,DPH
   \   000015   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   1682          
   1683            if ( entry != NULL )
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   7002         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000022   6042         JZ      ??CrossCallReturnLabel_40
   1684            {
   1685              // lookup device control data
   1686              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000024                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000036   12....       LCALL   ?Subroutine51 & 0xFFFF
   1687          
   1688              // make sure control data is valid
   1689              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_89:
   \   000039   7002         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00003D   6027         JZ      ??CrossCallReturnLabel_40
   1690              {
   1691                // possible state transitions
   1692                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   2405         ADD     A,#0x5
   \   000048   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   6404         XRL     A,#0x4
   \   00004E   7016         JNZ     ??CrossCallReturnLabel_40
   1693                {
   1694                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000050   7405         MOV     A,#0x5
   \   000052   6E           XRL     A,R6
   \   000053   7004         JNZ     ??ZDSecMgrDeviceCtrlUpdate_2
   1695                  {
   1696                    // send the network key
   1697                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000055   7407         MOV     A,#0x7
   \   000057   8007         SJMP    ??ZDSecMgrDeviceCtrlUpdate_3
   1698                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1699                  }
   1700                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_2:
   \   000059   7406         MOV     A,#0x6
   \   00005B   6E           XRL     A,R6
   \   00005C   7008         JNZ     ??CrossCallReturnLabel_40
   1701                  {
   1702                    // force default timeout in order to cleanup control logic
   1703                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   00005E   7406         MOV     A,#0x6
   1704                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1705                  }
   1706                }
   1707                // timer should be active
   1708              }
   1709            }
   \                     ??ZDSecMgrDeviceCtrlUpdate_3:
   \   000060   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000063   12....       LCALL   ?Subroutine23 & 0xFFFF
   1710          }
   \                     ??CrossCallReturnLabel_40:
   \   000066                REQUIRE ?Subroutine82
   \   000066                ; // Fall through to label ?Subroutine82

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   7404         MOV     A,#0x4
   \   000002   02....       LJMP    ??Subroutine95_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   22           RET
   1711          
   1712          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1713          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1714          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1715            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1716            {
   1717              if ( initiator == TRUE )
   1718              {
   1719                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1720              }
   1721            }
   1722          }
   \   000000   02....       LJMP    ?BRET
   1723          
   1724          /******************************************************************************
   1725           * @fn          ZDSecMgrDeviceRemove
   1726           *
   1727           * @brief       Remove device from network.
   1728           *
   1729           * @param       device - [in] ZDSecMgrDevice_t, device info
   1730           *
   1731           * @return      none
   1732           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1733          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1734          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1735            APSME_RemoveDeviceReq_t remDevReq;
   1736            NLME_LeaveReq_t         leaveReq;
   1737            associated_devices_t*   assoc;
   1738          
   1739          
   1740            // check if parent, remove the device
   1741            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000011   8A..         MOV     ?V0 + 0,R2
   \   000013   8B..         MOV     ?V0 + 1,R3
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \   000018   F8           MOV     R0,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F9           MOV     R1,A
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   12....       LCALL   ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FE           MOV     R6,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FF           MOV     R7,A
   \   000035   E5..         MOV     A,?V0 + 0
   \   000037   6E           XRL     A,R6
   \   000038   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00003A   E5..         MOV     A,?V0 + 1
   \   00003C   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00003D   7057         JNZ     ??ZDSecMgrDeviceRemove_1
   1742            {
   1743              // this is the parent of the device
   1744              leaveReq.extAddr        = device->extAddr;
   \   00003F   12....       LCALL   ?Subroutine17 & 0xFFFF
   1745              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_123:
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E4           CLR     A
   \   000046   F0           MOVX    @DPTR,A
   1746              leaveReq.rejoin         = FALSE;
   \   000047   7403         MOV     A,#0x3
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E4           CLR     A
   \   00004D   F0           MOVX    @DPTR,A
   1747          
   1748              // find child association
   1749              assoc = AssocGetWithExt( device->extAddr );
   \   00004E                ; Setup parameters for call to function AssocGetWithExt
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000055   8A..         MOV     ?V0 + 0,R2
   \   000057   8B..         MOV     ?V0 + 1,R3
   \   000059   A8..         MOV     R0,?V0 + 0
   \   00005B   A9..         MOV     R1,?V0 + 1
   1750          
   1751              if ( ( assoc != NULL                            ) &&
   1752                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1753                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00005D   E8           MOV     A,R0
   \   00005E   7001         JNZ     ??ZDSecMgrDeviceRemove_2
   \   000060   E9           MOV     A,R1
   \                     ??ZDSecMgrDeviceRemove_2:
   \   000061   604F         JZ      ??ZDSecMgrDeviceRemove_3
   \   000063   8882         MOV     DPL,R0
   \   000065   8983         MOV     DPH,R1
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6044         JZ      ??ZDSecMgrDeviceRemove_3
   \   00006E   C3           CLR     C
   \   00006F   9405         SUBB    A,#0x5
   \   000071   503F         JNC     ??ZDSecMgrDeviceRemove_3
   1754              {
   1755                // check if associated device is authenticated
   1756                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   A2E3         MOV     C,0xE0 /* A   */.3
   \   00007F   7404         MOV     A,#0x4
   \   000081   5006         JNC     ??ZDSecMgrDeviceRemove_4
   1757                {
   1758                  leaveReq.silent = FALSE;
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   E4           CLR     A
   \   000087   8005         SJMP    ??ZDSecMgrDeviceRemove_5
   1759                }
   1760                else
   1761                {
   1762                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_4:
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   7401         MOV     A,#0x1
   1763                }
   1764          
   1765                NLME_LeaveReq( &leaveReq );
   1766              }
   1767            }
   \                     ??ZDSecMgrDeviceRemove_5:
   \   00008E   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000091   12....       LCALL   ??NLME_LeaveReq?relay
   \   000094   801C         SJMP    ??ZDSecMgrDeviceRemove_3
   1768            else
   1769            {
   1770              // this is not the parent of the device
   1771              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000096   7405         MOV     A,#0x5
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   EE           MOV     A,R6
   \   00009C   F0           MOVX    @DPTR,A
   \   00009D   A3           INC     DPTR
   \   00009E   EF           MOV     A,R7
   \   00009F   F0           MOVX    @DPTR,A
   1772              remDevReq.childExtAddr = device->extAddr;
   \   0000A0   7407         MOV     A,#0x7
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   12....       LCALL   ??Subroutine89_0 & 0xFFFF
   1773          
   1774              APSME_RemoveDeviceReq( &remDevReq );
   1775            }
   \                     ??CrossCallReturnLabel_119:
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   1776          }
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000B2   7409         MOV     A,#0x9
   \   0000B4   80..         SJMP    ??Subroutine91_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine93_0
   \   000006                ; // Fall through to label ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   12....       LCALL   ??AssocGetWithExt?relay
   \   000006   22           RET
   1777          
   1778          /******************************************************************************
   1779           * @fn          ZDSecMgrDeviceValidateSKKE
   1780           *
   1781           * @brief       Decide whether device is allowed for SKKE.
   1782           *
   1783           * @param       device - [in] ZDSecMgrDevice_t, device info
   1784           *
   1785           * @return      ZStatus_t
   1786           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1787          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1788          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1789            ZStatus_t status;
   1790            uint16    ami;
   1791            uint8*    key;
   1792          
   1793          
   1794            // get EXT address
   1795            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000021   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000024   E9           MOV     A,R1
   1796          
   1797            if ( status == ZSuccess )
   \   000025   700D         JNZ     ??CrossCallReturnLabel_46
   1798            {
   1799              // get MASTER key
   1800              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   000027                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ?Subroutine24 & 0xFFFF
   1801          
   1802              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_42:
   \   00002F   7003         JNZ     ??CrossCallReturnLabel_46
   1803              {
   1804              //  // check if initiator is Trust Center
   1805              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1806              //  {
   1807              //    // verify NWK key not sent
   1808              //    // devtag.todo
   1809              //    // temporary - add device to internal data
   1810              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1811              //  }
   1812              //  else
   1813              //  {
   1814              //    // initiator not Trust Center - End to End SKKE - set policy
   1815              //    // for accepting an SKKE initiation
   1816              //    // temporary - add device to internal data
   1817              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1818              //  }
   1819                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000031                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000031   12....       LCALL   ?Subroutine26 & 0xFFFF
   1820              }
   1821            }
   1822          
   1823            return status;
   \                     ??CrossCallReturnLabel_46:
   \   000034   02....       LJMP    ?Subroutine82 & 0xFFFF
   1824          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FC           MOV     R4,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FD           MOV     R5,A
   \   00000B   EE           MOV     A,R6
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   FB           MOV     R3,A
   \   00000F   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   000012   22           RET
   1825          
   1826          /******************************************************************************
   1827           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1828           *
   1829           * @brief       Decide whether device is allowed.
   1830           *
   1831           * @param       device - [in] ZDSecMgrDevice_t, device info
   1832           *
   1833           * @return      ZStatus_t
   1834           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1835          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1836          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1837          
   1838            ZStatus_t status;
   1839            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1840          
   1841            (void)device;  // Intentionally unreferenced parameter
   1842            
   1843            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1844            // the trust center to reject any newly joining devices by sending
   1845            // Remove-device to the parents.
   1846            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1847            {
   1848              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1849            }
   1850          
   1851          
   1852          
   1853          #if 0  // Taken out because the following functionality is only used for test
   1854                 // purpose. A more efficient (above) way is used. It can be put
   1855                 // back in if customers request for a white/black list feature.
   1856                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1857          
   1858            // The following code processes the device black list (stored device list)
   1859            // If the joining device is not part of the forbidden device list
   1860            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1861            // will send Remove-device and ban the device from joining.
   1862          
   1863            uint8     index;
   1864            uint8*    restricted;
   1865          
   1866            // Look through the stored device list - used for restricted devices
   1867            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1868            {
   1869              restricted = ZDSecMgrStoredDeviceList[index];
   1870          
   1871              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1872              {
   1873                // return as unknown device in regards to validation
   1874                status = ZNwkUnknownDevice;
   1875          
   1876                // break from loop
   1877                index = ZDSECMGR_STORED_DEVICES;
   1878              }
   1879            }
   1880          
   1881          #endif
   1882          
   1883            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   1884          }
   1885          
   1886          /******************************************************************************
   1887           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1888           *
   1889           * @brief       Decide whether device is allowed.
   1890           *
   1891           * @param       device - [in] ZDSecMgrDevice_t, device info
   1892           *
   1893           * @return      ZStatus_t
   1894           */
   1895          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1897          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903          //  // check for pre configured setting
   1904          //  if ( device->secure == TRUE )
   1905          //  {
   1906          //    // get EXT address and MASTER key
   1907          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          //
   1909          //    if ( status == ZSuccess )
   1910          //    {
   1911          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912          //    }
   1913          //  }
   1914          //  else
   1915          //  {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              //status = ZNwkUnknownDevice;
   1922          
   1923              // set status based on policy
   1924              status = ZSuccess; // ZNwkUnknownDevice;
   1925          
   1926              // get key based on policy
   1927              key = ZDSecMgrTCMasterKey;
   1928          
   1929              // if policy, store new EXT address
   1930              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000014                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   8582..       MOV     ?V0 + 2,DPL
   \   00001D   8583..       MOV     ?V0 + 3,DPH
   \   000020   78..         MOV     R0,#?V0 + 2
   \   000022   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000025   85..82       MOV     DPL,?V0 + 0
   \   000028   8983         MOV     DPH,R1
   \   00002A   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00002D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000030   E9           MOV     A,R1
   \   000031   F5..         MOV     ?V0 + 2,A
   1931          
   1932              // set the key
   1933              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000033                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000033   7C..         MOV     R4,#(ZDSecMgrTCMasterKey & 0xff)
   \   000035   7D..         MOV     R5,#((ZDSecMgrTCMasterKey >> 8) & 0xff)
   \   000037   85..82       MOV     DPL,?V0 + 0
   \   00003A   85..83       MOV     DPH,?V0 + 1
   \   00003D   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000040   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   1934          //  }
   1935          
   1936            // if EXT address and MASTER key available -- add device
   1937            if ( status == ZSuccess )
   \   000043   E5..         MOV     A,?V0 + 2
   \   000045   7006         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1938            {
   1939              // add device to internal data - with control
   1940              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000047                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000047   12....       LCALL   ?Subroutine26 & 0xFFFF
   1941            }
   \                     ??CrossCallReturnLabel_47:
   \   00004A   E9           MOV     A,R1
   \   00004B   F5..         MOV     ?V0 + 2,A
   1942          
   1943            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   00004D   A9..         MOV     R1,?V0 + 2
   \   00004F   7402         MOV     A,#0x2
   \   000051   02....       LJMP    ??Subroutine102_0 & 0xFFFF
   1944          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   8E82         MOV     DPL,R6
   \   000007   8F83         MOV     DPH,R7
   \   000009   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   00000C   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00000F   7402         MOV     A,#0x2
   \   000011   22           RET
   1945          //devtag.pro.security
   1946          #if 0
   1947          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1948          {
   1949            ZStatus_t status;
   1950            uint16    ami;
   1951            uint8*    key;
   1952          
   1953          
   1954            // check for pre configured setting
   1955            if ( device->secure == TRUE )
   1956            {
   1957              // get EXT address and MASTER key
   1958              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1959          
   1960              if ( status == ZSuccess )
   1961              {
   1962                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1963              }
   1964            }
   1965            else
   1966            {
   1967              // implement EXT address and MASTER key policy here -- the total number of
   1968              // Security Manager entries should never exceed the number of EXT addresses
   1969              // and MASTER keys available
   1970          
   1971              // set status based on policy
   1972              status = ZSuccess; // ZNwkUnknownDevice;
   1973          
   1974              // get the address index
   1975              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1976              {
   1977                // if policy, store new EXT address
   1978                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1979              }
   1980          
   1981              // get the address index
   1982              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1983              {
   1984                // if policy, store new key -- NULL will zero key
   1985                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1986              }
   1987            }
   1988          
   1989            // if EXT address and MASTER key available -- add device
   1990            if ( status == ZSuccess )
   1991            {
   1992              // add device to internal data - with control
   1993              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1994            }
   1995          
   1996            return status;
   1997          }
   1998          #endif
   1999          
   2000          /******************************************************************************
   2001           * @fn          ZDSecMgrDeviceValidate
   2002           *
   2003           * @brief       Decide whether device is allowed.
   2004           *
   2005           * @param       device - [in] ZDSecMgrDevice_t, device info
   2006           *
   2007           * @return      ZStatus_t
   2008           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2009          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   2010          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2011            ZStatus_t status;
   2012          
   2013          
   2014            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   701F         JNZ     ??ZDSecMgrDeviceValidate_0
   2015            {
   2016              // device may be joining with a secure flag but it is ultimately the Trust
   2017              // Center that decides -- check if expected pre configured device --
   2018              // override settings
   2019              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV     A,R2
   \   00000D   2406         ADD     A,#0x6
   \   00000F   F8           MOV     R0,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#zgPreConfigKeys
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   7004         JNZ     ??ZDSecMgrDeviceValidate_1
   2020              {
   2021                device->secure = TRUE;
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrDeviceValidate_2
   2022              }
   2023              else
   2024              {
   2025                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000021   8882         MOV     DPL,R0
   \   000023   8983         MOV     DPH,R1
   \   000025   F0           MOVX    @DPTR,A
   2026              }
   2027          
   2028              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2029              {
   2030                status = ZDSecMgrDeviceValidateCM( device );
   2031              }
   2032              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2033              {
   2034                status = ZDSecMgrDeviceValidateRM( device );
   \   000026                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000026   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   000029   8002         SJMP    ??ZDSecMgrDeviceValidate_3
   2035              }
   2036            }
   2037            else
   2038            {
   2039              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002B   79C8         MOV     R1,#-0x38
   2040            }
   2041          
   2042            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002D   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   2043          }
   2044          
   2045          /******************************************************************************
   2046           * @fn          ZDSecMgrDeviceJoin
   2047           *
   2048           * @brief       Try to join this device.
   2049           *
   2050           * @param       device - [in] ZDSecMgrDevice_t, device info
   2051           *
   2052           * @return      ZStatus_t
   2053           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2054          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2055          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2056            ZStatus_t status;
   2057            uint16    ami;
   2058          
   2059            // attempt to validate device
   2060            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   000011   E9           MOV     A,R1
   \   000012   F5..         MOV     ?V0 + 0,A
   2061          
   2062            if ( status == ZSuccess )
   \   000014   7029         JNZ     ??ZDSecMgrDeviceJoin_0
   2063            {
   2064              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2065              {
   2066                ZDSecMgrDeviceCtrlSetup( device );
   2067              }
   2068              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2069              {
   2070                // Add the device to the address manager
   2071                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   8582..       MOV     ?V0 + 0,DPL
   \   00001F   8583..       MOV     ?V0 + 1,DPH
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000030   12....       LCALL   ?DEALLOC_XSTACK8
   2072                //send the nwk key data to the joining device
   2073                status = ZDSecMgrSendNwkKey( device );
   \   000033                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000033   EE           MOV     A,R6
   \   000034   FA           MOV     R2,A
   \   000035   EF           MOV     A,R7
   \   000036   FB           MOV     R3,A
   \   000037   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   00003A   E9           MOV     A,R1
   \   00003B   F5..         MOV     ?V0 + 0,A
   \   00003D   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2074              }
   2075            }
   2076            else
   2077            {
   2078              // not allowed, remove the device
   2079              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00003F                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00003F   EE           MOV     A,R6
   \   000040   FA           MOV     R2,A
   \   000041   EF           MOV     A,R7
   \   000042   FB           MOV     R3,A
   \   000043   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2080            }
   2081          
   2082            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000046   A9..         MOV     R1,?V0 + 0
   \   000048   02....       LJMP    ?Subroutine83 & 0xFFFF
   2083          }
   2084          
   2085          /******************************************************************************
   2086           * @fn          ZDSecMgrDeviceJoinDirect
   2087           *
   2088           * @brief       Try to join this device as a direct child.
   2089           *
   2090           * @param       device - [in] ZDSecMgrDevice_t, device info
   2091           *
   2092           * @return      ZStatus_t
   2093           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2094          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2095          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2096            ZStatus_t status;
   2097          
   2098            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2099          
   2100            if ( status == ZSuccess )
   \   00000F   700D         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2101            {
   2102              // set association status to authenticated
   2103              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   2104            }
   \                     ??CrossCallReturnLabel_130:
   \   000018   12....       LCALL   ??AssocGetWithShort?relay
   \   00001B   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2105          
   2106            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001E   A9..         MOV     R1,?V0 + 0
   \   000020   02....       LJMP    ??Subroutine96_0 & 0xFFFF
   2107          }
   2108          
   2109          /******************************************************************************
   2110           * @fn          ZDSecMgrDeviceJoinFwd
   2111           *
   2112           * @brief       Forward join to Trust Center.
   2113           *
   2114           * @param       device - [in] ZDSecMgrDevice_t, device info
   2115           *
   2116           * @return      ZStatus_t
   2117           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2118          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2119          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2120            ZStatus_t               status;
   2121            APSME_UpdateDeviceReq_t req;
   2122          
   2123          
   2124            // forward any joining device to the Trust Center -- the Trust Center will
   2125            // decide if the device is allowed to join
   2126            status = ZSuccess;
   2127          
   2128            // forward authorization to the Trust Center
   2129            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
   2130            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine4 & 0xFFFF
   2131            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_5:
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   2132          
   2133            // set security status, option for router to reject if policy set
   2134            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_176:
   \   000026   EA           MOV     A,R2
   \   000027   2407         ADD     A,#0x7
   \   000029   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   00002C   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002E   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2135            {
   2136              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000030   A2E6         MOV     C,0xE0 /* A   */.6
   \   000032   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2137              {
   2138                if ( device->secure == TRUE )
   \   000034   8A82         MOV     DPL,R2
   \   000036   8B83         MOV     DPH,R3
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   6401         XRL     A,#0x1
   \   000041   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2139                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000043   7406         MOV     A,#0x6
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   7404         MOV     A,#0x4
   \   00004A   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2140                else
   2141                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00004C   7406         MOV     A,#0x6
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   7407         MOV     A,#0x7
   \   000053   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2142              }
   2143              else
   2144                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000055   7406         MOV     A,#0x6
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   7405         MOV     A,#0x5
   \   00005C   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2145            }
   2146            else
   2147            {
   2148              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   00005E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000060   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2149              {
   2150                if ( device->secure == TRUE )
   \   000062   8A82         MOV     DPL,R2
   \   000064   8B83         MOV     DPH,R3
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   6401         XRL     A,#0x1
   \   00006F   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2151                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000071   7406         MOV     A,#0x6
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   E4           CLR     A
   \   000077   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2152                else
   2153                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000079   7406         MOV     A,#0x6
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   7403         MOV     A,#0x3
   \   000080   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2154              }
   2155              else
   2156                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000082   7406         MOV     A,#0x6
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   000089   F0           MOVX    @DPTR,A
   2157            }
   2158          
   2159            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2160              req.apsSecure = TRUE;
   2161            else
   2162              req.apsSecure = FALSE;
   \   00008A   7407         MOV     A,#0x7
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   E4           CLR     A
   \   000090   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2163          
   2164            // send and APSME_UPDATE_DEVICE request to the trust center
   2165            status = APSME_UpdateDeviceReq( &req );
   2166          
   2167            return status;
   \                     ??CrossCallReturnLabel_145:
   \   000093   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   000096   7408         MOV     A,#0x8
   \   000098   02....       LJMP    ??Subroutine110_0 & 0xFFFF
   2168          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   F582         MOV     DPL,A
   \   000002   EB           MOV     A,R3
   \   000003                REQUIRE ??Subroutine98_0
   \   000003                ; // Fall through to label ??Subroutine98_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine98_0:
   \   000000   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   00000A   7404         MOV     A,#0x4
   \   00000C   22           RET
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrDeviceNew
   2172           *
   2173           * @brief       Process a new device.
   2174           *
   2175           * @param       device - [in] ZDSecMgrDevice_t, device info
   2176           *
   2177           * @return      ZStatus_t
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2180          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2181            ZStatus_t status;
   2182          
   2183            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2184            {
   2185              // try to join this device
   2186              status = ZDSecMgrDeviceJoinDirect( joiner );
   2187            }
   2188            else
   2189            {
   2190              status = ZDSecMgrDeviceJoinFwd( joiner );
   2191            }
   2192          
   2193            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay
   \   000007   80..         SJMP    ??Subroutine100_0
   2194          }
   2195          
   2196          /******************************************************************************
   2197           * @fn          ZDSecMgrAssocDeviceAuth
   2198           *
   2199           * @brief       Set associated device status to authenticated
   2200           *
   2201           * @param       assoc - [in, out] associated_devices_t
   2202           *
   2203           * @return      none
   2204           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2205          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2206          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2207            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??ZDSecMgrAssocDeviceAuth_0
   \   000007   EB           MOV     A,R3
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000008   600D         JZ      ??ZDSecMgrAssocDeviceAuth_1
   2208            {
   2209              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   D2E3         SETB    0xE0 /* A   */.3
   \   000016   F0           MOVX    @DPTR,A
   2210            }
   2211          }
   \                     ??ZDSecMgrAssocDeviceAuth_1:
   \   000017   80..         SJMP    ??Subroutine100_0
   2212          
   2213          /******************************************************************************
   2214           * @fn          ZDSecMgrAuthInitiate
   2215           *
   2216           * @brief       Initiate entity authentication
   2217           *
   2218           * @param       responder - [in] responder EXT address
   2219           *
   2220           * @return      none
   2221           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2222          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2223          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2224            APSME_AuthenticateReq_t req;
   2225          
   2226          
   2227            // make sure NWK address is available
   2228            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   601F         JZ      ??ZDSecMgrAuthInitiate_0
   2229            {
   2230              // set request fields
   2231              req.extAddr   = responder;
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   2232              req.action    = APSME_EA_INITIATE;
   \   000028   7406         MOV     A,#0x6
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
   2233              req.challenge = NULL;
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2234          
   2235              // start EA processing
   2236              APSME_AuthenticateReq( &req );
   2237            }
   \                     ??CrossCallReturnLabel_146:
   \   00003A   12....       LCALL   ??APSME_AuthenticateReq?relay
   2238          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   00003D   7407         MOV     A,#0x7
   \   00003F   02....       LJMP    ??Subroutine95_0 & 0xFFFF
   2239          
   2240          /******************************************************************************
   2241           * @fn          ZDSecMgrAuthNwkKey
   2242           *
   2243           * @brief       Handle next step in authentication process
   2244           *
   2245           * @param       none
   2246           *
   2247           * @return      none
   2248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2249          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2250          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2251            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   2252            {
   2253              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2254              {
   2255                uint8 parent[Z_EXTADDR_LEN];
   2256          
   2257                // get parent's EXT address
   2258                NLME_GetCoordExtAddr( parent );
   2259          
   2260                // begin entity authentication with parent
   2261                ZDSecMgrAuthInitiate( parent );
   2262              }
   2263              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2264              {
   2265                // inform ZDO that device has been authenticated
   2266                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   2267              }
   2268            }
   2269          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine100_0
   2270          
   2271          /******************************************************************************
   2272           * PUBLIC FUNCTIONS
   2273           */
   2274          /******************************************************************************
   2275           * @fn          ZDSecMgrInit
   2276           *
   2277           * @brief       Initialize ZigBee Device Security Manager.
   2278           *
   2279           * @param       state - device initialization state
   2280           *
   2281           * @return      none
   2282           */
   2283          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2284          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2285          void ZDSecMgrAddrMgrCB( uint8           update,
   2286                                  AddrMgrEntry_t* newEntry,
   2287                                  AddrMgrEntry_t* oldEntry )
   2288          {
   2289            (void)update;
   2290            (void)newEntry;
   2291            (void)oldEntry;
   2292          }
   2293          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2294          
   2295          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   \   000000                REQUIRE ?Subroutine79
   \   000000                ; // Fall through to label ?Subroutine79

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   \   000007   80..         SJMP    ??Subroutine100_0
   2296          {
   2297            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2298                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2299            {
   2300              // initialize sub modules
   2301              ZDSecMgrMasterKeyInit();
   2302              ZDSecMgrEntryInit(state);
   2303          
   2304              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2305              {
   2306                ZDSecMgrCtrlInit();
   2307              }
   2308          
   2309              // register with Address Manager
   2310              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2311              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2312              #endif
   2313            }
   2314          
   2315            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2316            {
   2317              // configure SKA slot data
   2318              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2319            }
   2320            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2321            {
   2322              APSME_TCLinkKeyInit();  
   2323              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2324            
   2325            }
   2326          
   2327            if ( ZG_SECURE_ENABLED )
   2328            {
   2329              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2330              {
   2331                // setup joining permissions
   2332                ZDSecMgrPermitJoiningEnabled = TRUE;
   2333                ZDSecMgrPermitJoiningTimed   = FALSE;
   2334              }
   2335            }
   2336          
   2337            // configure security based on security mode and type of device
   2338            ZDSecMgrConfig();
   2339          }
   2340          
   2341          /******************************************************************************
   2342           * @fn          ZDSecMgrConfig
   2343           *
   2344           * @brief       Configure ZigBee Device Security Manager.
   2345           *
   2346           * @param       none
   2347           *
   2348           * @return      none
   2349           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2350          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   80..         SJMP    ?Subroutine79
   2351          {
   2352            if ( ZG_SECURE_ENABLED )
   2353            {
   2354              SSP_Init();
   2355          
   2356              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2357                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2358              {
   2359                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2360                {
   2361                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2362                  APSME_SecurityCM_CD();
   2363                }
   2364                else if ( ZSTACK_ROUTER_BUILD )
   2365                {
   2366                  // COMMERCIAL MODE - ROUTER DEVICE
   2367                  APSME_SecurityCM_RD();
   2368                }
   2369                else
   2370                {
   2371                  // COMMERCIAL MODE - END DEVICE
   2372                  APSME_SecurityCM_ED();
   2373                }
   2374              }
   2375              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2376              {
   2377                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2378                {
   2379                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2380                  APSME_SecurityRM_CD();
   2381                }
   2382                else if ( ZSTACK_ROUTER_BUILD )
   2383                {
   2384                  // RESIDENTIAL MODE - ROUTER DEVICE
   2385                  APSME_SecurityRM_RD();
   2386                }
   2387                else
   2388                {
   2389                  // RESIDENTIAL MODE - END DEVICE
   2390                  APSME_SecurityRM_ED();
   2391                }
   2392              }
   2393            }
   2394            else
   2395            {
   2396              // NO SECURITY
   2397              APSME_SecurityNM();
   2398            }
   2399          }
   2400          
   2401          /******************************************************************************
   2402           * @fn          ZDSecMgrPermitJoining
   2403           *
   2404           * @brief       Process request to change joining permissions.
   2405           *
   2406           * @param       duration - [in] timed duration for join in seconds
   2407           *                         - 0x00 not allowed
   2408           *                         - 0xFF allowed without timeout
   2409           *
   2410           * @return      uint8 - success(TRUE:FALSE)
   2411           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2412          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2413          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2414            uint8 accept;
   2415          
   2416          
   2417            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000004   E4           CLR     A
   \   000005   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000008   F0           MOVX    @DPTR,A
   2418          
   2419            if ( duration > 0 )
   \   000009   E9           MOV     A,R1
   \   00000A   6012         JZ      ??ZDSecMgrPermitJoining_0
   2420            {
   2421              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00000C   7401         MOV     A,#0x1
   \   00000E   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000011   F0           MOVX    @DPTR,A
   2422          
   2423              if ( duration != 0xFF )
   \   000012   74FF         MOV     A,#-0x1
   \   000014   69           XRL     A,R1
   \   000015   600C         JZ      ??ZDSecMgrPermitJoining_1
   2424              {
   2425                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000017   7401         MOV     A,#0x1
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   8004         SJMP    ??ZDSecMgrPermitJoining_2
   2426              }
   2427            }
   2428            else
   2429            {
   2430              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   00001E   E4           CLR     A
   \   00001F   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \                     ??ZDSecMgrPermitJoining_2:
   \   000022   F0           MOVX    @DPTR,A
   2431            }
   2432          
   2433            accept = TRUE;
   2434          
   2435            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000023   7901         MOV     R1,#0x1
   \   000025   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   2436          }
   2437          
   2438          /******************************************************************************
   2439           * @fn          ZDSecMgrPermitJoiningTimeout
   2440           *
   2441           * @brief       Process permit joining timeout
   2442           *
   2443           * @param       none
   2444           *
   2445           * @return      none
   2446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2447          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2448          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2449            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2450            {
   2451              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   E4           CLR     A
   \   00000D   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000010   F0           MOVX    @DPTR,A
   2452              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   2453            }
   2454          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   2455          
   2456          /******************************************************************************
   2457           * @fn          ZDSecMgrNewDeviceEvent
   2458           *
   2459           * @brief       Process a the new device event, if found reset new device
   2460           *              event/timer.
   2461           *
   2462           * @param       none
   2463           *
   2464           * @return      uint8 - found(TRUE:FALSE)
   2465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2466          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2467          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2468            uint8                 found;
   2469            ZDSecMgrDevice_t      device;
   2470            AddrMgrEntry_t        addrEntry;
   2471            associated_devices_t* assoc;
   2472            ZStatus_t             status;
   2473          
   2474            // initialize return results
   2475            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2476          
   2477            // look for device in the security init state
   2478            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2479          
   2480            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   7001         JNZ     ??ZDSecMgrNewDeviceEvent_0
   \   00001D   EF           MOV     A,R7
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrNewDeviceEvent_1 & 0xFFFF
   2481            {
   2482              // device found
   2483              found = TRUE;
   \   000023   75..01       MOV     ?V0 + 0,#0x1
   2484          
   2485              // check for preconfigured security
   2486              if ( zgPreConfigKeys == TRUE )
   \   000026   90....       MOV     DPTR,#zgPreConfigKeys
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6401         XRL     A,#0x1
   \   00002C   7003         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2487              {
   2488                // set association status to authenticated
   2489                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002E                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002E   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2490              }
   2491          
   2492              // set up device info
   2493              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   000031   740A         MOV     A,#0xa
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   2494              addrEntry.index = assoc->addrIdx;
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   12....       LCALL   ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000041   7415         MOV     A,#0x15
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   2495              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_200:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   AA82         MOV     R2,DPL
   \   00004E   AB83         MOV     R3,DPH
   \   000050   12....       LCALL   ??AddrMgrEntryGet?relay
   2496          
   2497              device.nwkAddr    = assoc->shortAddr;
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   12....       LCALL   ?Subroutine18 & 0xFFFF
   2498              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_184:
   \   00005A   740D         MOV     A,#0xd
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   A882         MOV     R0,DPL
   \   000061   A983         MOV     R1,DPH
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   2499              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_177:
   \   00006B                ; Setup parameters for call to function NLME_GetShortAddr
   \   00006B   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00006E   7404         MOV     A,#0x4
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   12....       LCALL   ?Subroutine13 & 0xFFFF
   2500              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_22:
   \   000076   7406         MOV     A,#0x6
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   E4           CLR     A
   \   00007C   F0           MOVX    @DPTR,A
   2501              device.devStatus  = assoc->devStatus;
   \   00007D   EE           MOV     A,R6
   \   00007E   2405         ADD     A,#0x5
   \   000080   F8           MOV     R0,A
   \   000081   EF           MOV     A,R7
   \   000082   3400         ADDC    A,#0x0
   \   000084   F9           MOV     R1,A
   \   000085   E8           MOV     A,R0
   \   000086   FE           MOV     R6,A
   \   000087   E9           MOV     A,R1
   \   000088   FF           MOV     R7,A
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   C0E0         PUSH    A
   \   000090   7407         MOV     A,#0x7
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   D0E0         POP     A
   \   000097   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2502          
   2503              // process new device
   2504              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_147:
   \   00009A   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   00009D   E9           MOV     A,R1
   \   00009E   FA           MOV     R2,A
   2505          
   2506              if ( status == ZSuccess )
   \   00009F   700A         JNZ     ??ZDSecMgrNewDeviceEvent_3
   2507              {
   2508                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000A1   8E82         MOV     DPL,R6
   \   0000A3   8F83         MOV     DPH,R7
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   C2E2         CLR     0xE0 /* A   */.2
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   8011         SJMP    ??ZDSecMgrNewDeviceEvent_1
   2509              }
   2510              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   0000AB   74C8         MOV     A,#-0x38
   \   0000AD   6A           XRL     A,R2
   \   0000AE   700C         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2511              {
   2512                AssocRemove( addrEntry.extAddr );
   \   0000B0                ; Setup parameters for call to function AssocRemove
   \   0000B0   740D         MOV     A,#0xd
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   AA82         MOV     R2,DPL
   \   0000B7   AB83         MOV     R3,DPH
   \   0000B9   12....       LCALL   ??AssocRemove?relay
   2513              }
   2514            }
   2515          
   2516            return found;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   0000BC   A9..         MOV     R1,?V0 + 0
   \   0000BE   7417         MOV     A,#0x17
   \   0000C0   80..         SJMP    ??Subroutine102_0
   2517          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000003                REQUIRE ??Subroutine105_0
   \   000003                ; // Fall through to label ??Subroutine105_0
   2518          
   2519          /******************************************************************************
   2520           * @fn          ZDSecMgrEvent
   2521           *
   2522           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2523           *
   2524           * @param       none
   2525           *
   2526           * @return      none
   2527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2528          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2529          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2530            uint8            action;
   2531            uint8            restart;
   2532            uint16           index;
   2533            AddrMgrEntry_t   entry;
   2534            ZDSecMgrDevice_t device;
   2535          
   2536          
   2537            // verify data is available
   2538            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7002         JNZ     ??ZDSecMgrEvent_0
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEvent_0:
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2539            {
   2540              action  = FALSE;
   \   000017   75..00       MOV     ?V0 + 1,#0x0
   2541              restart = FALSE;
   \   00001A   75..00       MOV     ?V0 + 0,#0x0
   2542          
   2543              // update all the counters
   2544              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001D   7E00         MOV     R6,#0x0
   \   00001F   7F00         MOV     R7,#0x0
   2545              {
   2546                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_2:
   \   000021   EE           MOV     A,R6
   \   000022   F8           MOV     R0,A
   \   000023   EF           MOV     A,R7
   \   000024   F9           MOV     R1,A
   \   000025   E8           MOV     A,R0
   \   000026   75F007       MOV     B,#0x7
   \   000029   A4           MUL     AB
   \   00002A   F8           MOV     R0,A
   \   00002B   AAF0         MOV     R2,B
   \   00002D   75F007       MOV     B,#0x7
   \   000030   E9           MOV     A,R1
   \   000031   A4           MUL     AB
   \   000032   2A           ADD     A,R2
   \   000033   F9           MOV     R1,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000037   E0           MOVX    A,@DPTR
   \   000038   28           ADD     A,R0
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   39           ADDC    A,R1
   \   00003D   FB           MOV     R3,A
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   7003         JNZ     $+5
   \   00004A   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2547                {
   2548                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00004D   EA           MOV     A,R2
   \   00004E   2406         ADD     A,#0x6
   \   000050   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000053   6002         JZ      ??ZDSecMgrEvent_4
   2549                  {
   2550                    ZDSecMgrCtrlData[index].cntr--;
   \   000055   14           DEC     A
   \   000056   F0           MOVX    @DPTR,A
   2551                  }
   2552          
   2553                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_4:
   \   000057   E5..         MOV     A,?V0 + 1
   \   000059   6003         JZ      $+5
   \   00005B   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   \   00005E   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000061   E0           MOVX    A,@DPTR
   \   000062   28           ADD     A,R0
   \   000063   F8           MOV     R0,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   39           ADDC    A,R1
   \   000067   F9           MOV     R1,A
   \   000068   8882         MOV     DPL,R0
   \   00006A   8983         MOV     DPH,R1
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   706D         JNZ     ??ZDSecMgrEvent_5
   2554                  {
   2555                    action = TRUE;
   \   000075   75..01       MOV     ?V0 + 1,#0x1
   2556          
   2557                    // update from control data
   2558                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   000078   8882         MOV     DPL,R0
   \   00007A   8983         MOV     DPH,R1
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   12....       LCALL   ??Subroutine97_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ?Subroutine13 & 0xFFFF
   2559                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_23:
   \   000089   8882         MOV     DPL,R0
   \   00008B   8983         MOV     DPH,R1
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   C0E0         PUSH    A
   \   000094   7406         MOV     A,#0x6
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   D0E0         POP     A
   \   00009B   F0           MOVX    @DPTR,A
   2560                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   00009C   7408         MOV     A,#0x8
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   2561          
   2562                    // set the user and address index
   2563                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_201:
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   7402         MOV     A,#0x2
   \   0000A9   F0           MOVX    @DPTR,A
   2564                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \   0000AA   8882         MOV     DPL,R0
   \   0000AC   8983         MOV     DPH,R1
   \   0000AE   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000B1   F9           MOV     R1,A
   \   0000B2   7415         MOV     A,#0x15
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   2565          
   2566                    // get the address data
   2567                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_202:
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   AA82         MOV     R2,DPL
   \   0000BF   AB83         MOV     R3,DPH
   \   0000C1   12....       LCALL   ??AddrMgrEntryGet?relay
   2568          
   2569                    // set device address data
   2570                    device.nwkAddr = entry.nwkAddr;
   \   0000C4   740B         MOV     A,#0xb
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   12....       LCALL   ?Subroutine18 & 0xFFFF
   2571                    device.extAddr = entry.extAddr;
   \                     ??CrossCallReturnLabel_185:
   \   0000CC   740D         MOV     A,#0xd
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   A882         MOV     R0,DPL
   \   0000D3   A983         MOV     R1,DPH
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   12....       LCALL   ?Subroutine0 & 0xFFFF
   2572          
   2573                    // update from entry data
   2574                    ZDSecMgrDeviceCtrlHandler( &device );
   2575                  }
   \                     ??CrossCallReturnLabel_0:
   \   0000DD   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   0000E0   8003         SJMP    ??ZDSecMgrEvent_3
   2576                  else
   2577                  {
   2578                    restart = TRUE;
   \                     ??ZDSecMgrEvent_5:
   \   0000E2   75..01       MOV     ?V0 + 0,#0x1
   2579                  }
   2580                }
   2581              }
   \                     ??ZDSecMgrEvent_3:
   \   0000E5   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0000E8   5003         JNC     $+5
   \   0000EA   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2582          
   2583              // check for timer restart
   2584              if ( restart == TRUE )
   \   0000ED   7401         MOV     A,#0x1
   \   0000EF   65..         XRL     A,?V0 + 0
   \   0000F1   7010         JNZ     ??ZDSecMgrEvent_1
   2585              {
   2586                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000F3                ; Setup parameters for call to function osal_start_timerEx
   \   0000F3   7C64         MOV     R4,#0x64
   \   0000F5   7D00         MOV     R5,#0x0
   \   0000F7   7A00         MOV     R2,#0x0
   \   0000F9   7B01         MOV     R3,#0x1
   \   0000FB   90....       MOV     DPTR,#ZDAppTaskID
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   F9           MOV     R1,A
   \   000100   12....       LCALL   ??osal_start_timerEx?relay
   2587              }
   2588            }
   2589          }
   \                     ??ZDSecMgrEvent_1:
   \   000103   7417         MOV     A,#0x17
   \   000105   02....       LJMP    ??Subroutine91_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000007   22           RET
   2590          
   2591          /******************************************************************************
   2592           * @fn          ZDSecMgrEstablishKeyCfm
   2593           *
   2594           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2595           *
   2596           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2597           *
   2598           * @return      none
   2599           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2600          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2601          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2602            // send the NWK key
   2603            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2604            {
   2605              // update control for specified EXT address
   2606              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2607            }
   2608            else
   2609            {
   2610              // this should be done when receiving the NWK key
   2611              // if devState ==
   2612              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2613                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2614          
   2615              // if not in joining state -- this should trigger an event for an
   2616              // end point that requested SKKE
   2617              // if ( devState == DEV_END_DEVICE )
   2618             //       devState == DEV_ROUTER;
   2619          
   2620            }
   2621          }
   \   000000   02....       LJMP    ?BRET
   2622          
   2623          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2624          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2625          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2626            uint8  match;
   2627            uint8  lookup[Z_EXTADDR_LEN];
   2628          
   2629            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2630          
   2631            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2632            {
   2633              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2634            }
   2635          
   2636            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   02....       LJMP    ??Subroutine95_0 & 0xFFFF
   2637          }
   2638          
   2639          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2640          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2641          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2642            uint16 ami;
   2643            uint8* key;
   2644          
   2645            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7043         JNZ     ??ZDSecMgrTCDataLoad_0
   2646            {
   2647              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   8582..       MOV     ?V0 + 0,DPL
   \   000019   8583..       MOV     ?V0 + 1,DPH
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   EA           MOV     A,R2
   \   000022   FC           MOV     R4,A
   \   000023   EB           MOV     A,R3
   \   000024   FD           MOV     R5,A
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000031   E9           MOV     A,R1
   \   000032   7019         JNZ     ??CrossCallReturnLabel_65
   2648              {
   2649                // if preconfigured load key
   2650                if ( zgPreConfigKeys == TRUE )
   \   000034   90....       MOV     DPTR,#zgPreConfigKeys
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6401         XRL     A,#0x1
   \   00003A   7011         JNZ     ??CrossCallReturnLabel_65
   2651                {
   2652                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000044   6007         JZ      ??CrossCallReturnLabel_65
   2653                  {
   2654                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   000046                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000046   7C..         MOV     R4,#(ZDSecMgrTCMasterKey & 0xff)
   \   000048   7D..         MOV     R5,#((ZDSecMgrTCMasterKey >> 8) & 0xff)
   \   00004A   12....       LCALL   ?Subroutine38 & 0xFFFF
   2655                  }
   2656                }
   2657              }
   2658          
   2659              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??CrossCallReturnLabel_65:
   \   00004D   7401         MOV     A,#0x1
   \   00004F   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000052   F0           MOVX    @DPTR,A
   2660            }
   2661          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000053   7404         MOV     A,#0x4
   \   000055   02....       LJMP    ??Subroutine91_0 & 0xFFFF
   2662          
   2663          /******************************************************************************
   2664           * @fn          ZDSecMgrEstablishKeyInd
   2665           *
   2666           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2667           *
   2668           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2669           *
   2670           * @return      none
   2671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006                REQUIRE ??Subroutine104_0
   \   000006                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2672          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2673          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2674            ZDSecMgrDevice_t        device;
   2675            APSME_EstablishKeyRsp_t rsp;
   2676          
   2677          
   2678            // load Trust Center data if needed
   2679            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000011                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000011   AA..         MOV     R2,?V0 + 0
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2680          
   2681            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   000017   EE           MOV     A,R6
   \   000018   2402         ADD     A,#0x2
   \   00001A   F8           MOV     R0,A
   \   00001B   EF           MOV     A,R7
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   F9           MOV     R1,A
   \   00001F   88..         MOV     ?V0 + 2,R0
   \   000021   89..         MOV     ?V0 + 3,R1
   \   000023                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000023   AA..         MOV     R2,?V0 + 0
   \   000025   AB..         MOV     R3,?V0 + 1
   \   000027   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   00002A   E9           MOV     A,R1
   \   00002B   6016         JZ      ??ZDSecMgrEstablishKeyInd_0
   2682            {
   2683              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2684              //OR
   2685              //!ZDSecMgrTCAuthenticated
   2686              //devtag.0604.critical
   2687                  //how is the parentAddr used here
   2688          
   2689              // initial SKKE from Trust Center via parent
   2690              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   00002D   7407         MOV     A,#0x7
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ?Subroutine8 & 0xFFFF
   2691              device.parentAddr = ind->srcAddr;
   2692            }
   \                     ??CrossCallReturnLabel_12:
   \   000038   740B         MOV     A,#0xb
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E8           MOV     A,R0
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   E9           MOV     A,R1
   \   000041   8013         SJMP    ??CrossCallReturnLabel_212
   2693            else
   2694            {
   2695              // Trust Center direct or E2E SKKE
   2696              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000043   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000046   7407         MOV     A,#0x7
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   2697              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_178:
   \   00004E   740B         MOV     A,#0xb
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   2698            }
   \                     ??CrossCallReturnLabel_212:
   \   000056   F0           MOVX    @DPTR,A
   2699          
   2700            device.extAddr = ind->initExtAddr;
   \   000057   7409         MOV     A,#0x9
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   2701            //devtag.pro.security.0724.todo - verify usage
   2702            device.secure  = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_222:
   \   00005F   EE           MOV     A,R6
   \   000060   240E         ADD     A,#0xe
   \   000062   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000065   C0E0         PUSH    A
   \   000067   740D         MOV     A,#0xd
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   D0E0         POP     A
   \   00006E   F0           MOVX    @DPTR,A
   2703          
   2704            // validate device for SKKE
   2705            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   00006F                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   00006F   7407         MOV     A,#0x7
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   AA82         MOV     R2,DPL
   \   000076   AB83         MOV     R3,DPH
   \   000078   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   00007B   E9           MOV     A,R1
   \   00007C   7009         JNZ     ??ZDSecMgrEstablishKeyInd_1
   2706            {
   2707              rsp.accept = TRUE;
   \   00007E   7404         MOV     A,#0x4
   \   000080   12....       LCALL   ?XSTACK_DISP0_8
   \   000083   7401         MOV     A,#0x1
   \   000085   8006         SJMP    ??ZDSecMgrEstablishKeyInd_2
   2708            }
   2709            else
   2710            {
   2711              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   E4           CLR     A
   2712            }
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   00008D   12....       LCALL   ?Subroutine8 & 0xFFFF
   2713          
   2714            rsp.dstAddr     = ind->srcAddr;
   \                     ??CrossCallReturnLabel_13:
   \   000090   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   2715            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_183:
   \   000093   EE           MOV     A,R6
   \   000094   2404         ADD     A,#0x4
   \   000096   F8           MOV     R0,A
   \   000097   EF           MOV     A,R7
   \   000098   3400         ADDC    A,#0x0
   \   00009A   F9           MOV     R1,A
   \   00009B   7402         MOV     A,#0x2
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   2716            //devtag.0604.todo - remove obsolete
   2717            rsp.apsSecure   = ind->apsSecure;
   \                     ??CrossCallReturnLabel_179:
   \   0000A3   EE           MOV     A,R6
   \   0000A4   240D         ADD     A,#0xd
   \   0000A6   F582         MOV     DPL,A
   \   0000A8   EF           MOV     A,R7
   \   0000A9   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000AC   C0E0         PUSH    A
   \   0000AE   7405         MOV     A,#0x5
   \   0000B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B3   D0E0         POP     A
   \   0000B5   12....       LCALL   ?Subroutine6 & 0xFFFF
   2718            rsp.nwkSecure   = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_11:
   \   0000B8   C0E0         PUSH    A
   \   0000BA   7406         MOV     A,#0x6
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   D0E0         POP     A
   \   0000C1   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2719          
   2720            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_148:
   \   0000C4   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   2721          }
   \   0000C7   7411         MOV     A,#0x11
   \   0000C9   02....       LJMP    ??Subroutine102_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 2
   \   000004   85..83       MOV     DPH,?V0 + 3
   \   000007   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   F8           MOV     R0,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   F9           MOV     R1,A
   \   000005   88..         MOV     ?V0 + 0,R0
   \   000007   89..         MOV     ?V0 + 1,R1
   \   000009                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000009   8882         MOV     DPL,R0
   \   00000B   F583         MOV     DPH,A
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   EE           MOV     A,R6
   \   000001   2404         ADD     A,#0x4
   \   000003   F5..         MOV     ?V0 + 0,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 1,A
   \   00000A   22           RET
   2722          //devtag.pro.security
   2723          #if 0
   2724          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2725          {
   2726            ZDSecMgrDevice_t        device;
   2727            APSME_EstablishKeyRsp_t rsp;
   2728          
   2729          
   2730            device.extAddr = ind->initExtAddr;
   2731            device.secure  = ind->secure;
   2732          
   2733            if ( ind->secure == FALSE )
   2734            {
   2735              // SKKE from Trust Center is not secured between child and parent
   2736              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2737              device.parentAddr = ind->srcAddr;
   2738            }
   2739            else
   2740            {
   2741              // SKKE from initiator should be secured
   2742              device.nwkAddr    = ind->srcAddr;
   2743              device.parentAddr = INVALID_NODE_ADDR;
   2744            }
   2745          
   2746            rsp.dstAddr     = ind->srcAddr;
   2747            rsp.initExtAddr = &ind->initExtAddr[0];
   2748            rsp.secure      = ind->secure;
   2749          
   2750            // validate device for SKKE
   2751            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2752            {
   2753              rsp.accept = TRUE;
   2754            }
   2755            else
   2756            {
   2757              rsp.accept = FALSE;
   2758            }
   2759          
   2760            APSME_EstablishKeyRsp( &rsp );
   2761          }
   2762          #endif
   2763          
   2764          /******************************************************************************
   2765           * @fn          ZDSecMgrTransportKeyInd
   2766           *
   2767           * @brief       Process the ZDO_TransportKeyInd_t message.
   2768           *
   2769           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2770           *
   2771           * @return      none
   2772           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2773          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2774          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2775            uint8 index;
   2776          
   2777            // load Trust Center data if needed
   2778            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EE           MOV     A,R6
   \   00000A   2416         ADD     A,#0x16
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2779          
   2780            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000014   EE           MOV     A,R6
   \   000015   2404         ADD     A,#0x4
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   00001D   6069         JZ      ??ZDSecMgrTransportKeyInd_0
   2781            {
   2782              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2783              //ZDSecMgrTCMasterKey( ind );
   2784              {
   2785                if ( zgPreConfigKeys != TRUE )
   2786                {
   2787                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2788                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2789                }
   2790                else
   2791                {
   2792                  // error condition - reject key
   2793                }
   2794              }
   2795            }
   2796            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2797                      ( ind->keyType == 6                 ) ||
   2798                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00001F   6401         XRL     A,#0x1
   \   000021   600A         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6406         XRL     A,#0x6
   \   000026   6005         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6405         XRL     A,#0x5
   \   00002B   705B         JNZ     ??ZDSecMgrTransportKeyInd_0
   2799            {
   2800              // check for dummy NWK key (all zeros)
   2801              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00002D   7A00         MOV     R2,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   00002F   8A..         MOV     ?V0 + 0,R2
   \   000031   EE           MOV     A,R6
   \   000032   25..         ADD     A,?V0 + 0
   \   000034   F582         MOV     DPL,A
   \   000036   EF           MOV     A,R7
   \   000037   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   7007         JNZ     ??ZDSecMgrTransportKeyInd_3
   2802                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2803                    index++ );
   \   000043   0A           INC     R2
   \   000044   EA           MOV     A,R2
   \   000045   C3           CLR     C
   \   000046   9410         SUBB    A,#0x10
   \   000048   40E5         JC      ??ZDSecMgrTransportKeyInd_2
   2804          
   2805              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00004A   7410         MOV     A,#0x10
   \   00004C   6A           XRL     A,R2
   \   00004D   7013         JNZ     ??ZDSecMgrTransportKeyInd_4
   2806              {
   2807                // load preconfigured key - once!!
   2808                if ( !_NIB.nwkKeyLoaded )
   \   00004F   90....       MOV     DPTR,#(_NIB + 61)
   \   000052   E0           MOVX    A,@DPTR
   \   000053   7030         JNZ     ??ZDSecMgrTransportKeyInd_5
   2809                {
   2810                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   000055                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000055   7900         MOV     R1,#0x0
   \   000057   7A..         MOV     R2,#(zgPreConfigKey & 0xff)
   \   000059   7B..         MOV     R3,#((zgPreConfigKey >> 8) & 0xff)
   \   00005B   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2811                  SSP_SwitchNwkKey( 0 );
   \   00005E                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00005E   7900         MOV     R1,#0x0
   \   000060   8020         SJMP    ??ZDSecMgrTransportKeyInd_6
   2812                }
   2813              }
   2814              else
   2815              {
   2816                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000062   EE           MOV     A,R6
   \   000063   2405         ADD     A,#0x5
   \   000065   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000068   F9           MOV     R1,A
   \   000069   EE           MOV     A,R6
   \   00006A   2406         ADD     A,#0x6
   \   00006C   FA           MOV     R2,A
   \   00006D   EF           MOV     A,R7
   \   00006E   3400         ADDC    A,#0x0
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2817                if ( !_NIB.nwkKeyLoaded )
   \   000074   90....       MOV     DPTR,#(_NIB + 61)
   \   000077   E0           MOVX    A,@DPTR
   \   000078   700B         JNZ     ??ZDSecMgrTransportKeyInd_5
   2818                {
   2819                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00007A                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00007A   85..82       MOV     DPL,?V0 + 0
   \   00007D   85..83       MOV     DPH,?V0 + 1
   \   000080   E0           MOVX    A,@DPTR
   \   000081   F9           MOV     R1,A
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   000082   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2820                }
   2821              }
   2822          
   2823              // handle next step in authentication process
   2824              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000085                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   000085   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   2825            }
   2826            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2827            {
   2828              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2829              {
   2830                //ZDSecMgrTCLinkKey( ind );
   2831              }
   2832            }
   2833            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2834            {
   2835              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2836              {
   2837                uint16           ami;
   2838                AddrMgrEntry_t   entry;
   2839                ZDSecMgrEntry_t* entryZD;
   2840          
   2841                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2842          
   2843                if ( ind->initiator == TRUE )
   2844                {
   2845                  // get the ami data
   2846                  entry.user  = ADDRMGR_USER_SECURITY;
   2847                  entry.index = ami;
   2848                  AddrMgrEntryGet( &entry );
   2849          
   2850                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2851                  {
   2852                    APSME_EstablishKeyReq_t req;
   2853                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2854          
   2855                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2856          
   2857                    if ( entryZD == NULL )
   2858                    {
   2859                      // get new entry
   2860                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2861                      {
   2862                        // finish setting up entry
   2863                        entryZD->ami = ami;
   2864                      }
   2865                    }
   2866          
   2867                    req.respExtAddr = ind->srcExtAddr;
   2868                    req.method      = APSME_SKKE_METHOD;
   2869                    req.dstAddr     = entry.nwkAddr;
   2870                    //devtag.0604.todo - remove obsolete
   2871                    req.apsSecure   = FALSE;
   2872                    req.nwkSecure   = TRUE;
   2873                    APSME_EstablishKeyReq( &req );
   2874                  }
   2875                }
   2876                else
   2877                {
   2878                  if ( ami == INVALID_NODE_ADDR )
   2879                  {
   2880                    // store new EXT address
   2881                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2882                  }
   2883          
   2884                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2885                }
   2886          
   2887                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2888                //{
   2889                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2890                //}
   2891              }
   2892            }
   2893            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2894            {
   2895              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2896              {
   2897                uint16           ami;
   2898                ZDSecMgrEntry_t* entry;
   2899          
   2900                // get the address index
   2901                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2902                {
   2903                  // store new EXT address
   2904                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2905                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2906                }
   2907          
   2908                ZDSecMgrEntryLookupAMI( ami, &entry );
   2909          
   2910                if ( entry == NULL )
   2911                {
   2912                  // get new entry
   2913                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2914                  {
   2915                    // finish setting up entry
   2916                    entry->ami = ami;
   2917                  }
   2918                }
   2919          
   2920                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2921              }
   2922            }
   2923          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000088   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2924          
   2925          /******************************************************************************
   2926           * @fn          ZDSecMgrUpdateDeviceInd
   2927           *
   2928           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2929           *
   2930           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2931           *
   2932           * @return      none
   2933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2934          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2935          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2936            ZDSecMgrDevice_t device;
   2937          
   2938          
   2939            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   EB           MOV     A,R3
   \   00000F   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000012   12....       LCALL   ?Subroutine18 & 0xFFFF
   2940            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_186:
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   F8           MOV     R0,A
   \   000019   EB           MOV     A,R3
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F9           MOV     R1,A
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine4 & 0xFFFF
   2941            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_6:
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   12....       LCALL   ?Subroutine0 & 0xFFFF
   2942          
   2943            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2944            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2945            //{
   2946            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2947            //  {
   2948            //    device.secure = TRUE;
   2949            //  }
   2950            //  else
   2951            //  {
   2952            //    device.secure = FALSE;
   2953            //  }
   2954          
   2955              // try to join this device
   2956              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_1:
   \   00002B   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   2957            //}
   2958          }
   \   00002E                REQUIRE ?Subroutine84
   \   00002E                ; // Fall through to label ?Subroutine84

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   740A         MOV     A,#0xa
   \   000002   80..         SJMP    ??Subroutine110_0
   2959          
   2960          /******************************************************************************
   2961           * @fn          ZDSecMgrRemoveDeviceInd
   2962           *
   2963           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2964           *
   2965           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2966           *
   2967           * @return      none
   2968           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2969          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2970          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2971            ZDSecMgrDevice_t device;
   2972          
   2973          
   2974            // only accept from Trust Center
   2975            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   7002         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000015   7022         JNZ     ??ZDSecMgrRemoveDeviceInd_1
   2976            {
   2977              // look up NWK address
   2978              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000017   EA           MOV     A,R2
   \   000018   2404         ADD     A,#0x4
   \   00001A   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   00001D   701A         JNZ     ??ZDSecMgrRemoveDeviceInd_1
   2979              {
   2980                device.parentAddr = NLME_GetShortAddr();
   \   00001F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00001F   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000022   7404         MOV     A,#0x4
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine13 & 0xFFFF
   2981                device.extAddr    = ind->childExtAddr;
   \                     ??CrossCallReturnLabel_24:
   \   00002A   7402         MOV     A,#0x2
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   EE           MOV     A,R6
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   EF           MOV     A,R7
   \   000033   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2982          
   2983                // remove device
   2984                ZDSecMgrDeviceRemove( &device );
   2985              }
   2986            }
   \                     ??CrossCallReturnLabel_149:
   \   000036   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2987          }
   \                     ??ZDSecMgrRemoveDeviceInd_1:
   \   000039   740A         MOV     A,#0xa
   \   00003B   02....       LJMP    ??Subroutine95_0 & 0xFFFF
   2988          
   2989          /******************************************************************************
   2990           * @fn          ZDSecMgrRequestKeyInd
   2991           *
   2992           * @brief       Process the ZDO_RequestKeyInd_t message.
   2993           *
   2994           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2995           *
   2996           * @return      none
   2997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2998          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2999          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3000            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   FC           MOV     R4,A
   \   00000E   7401         MOV     A,#0x1
   \   000010   6C           XRL     A,R4
   \   000011   6008         JZ      ??ZDSecMgrRequestKeyInd_0
   3001            {
   3002            }
   3003            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV     A,#0x2
   \   000015   6C           XRL     A,R4
   \   000016   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   3004            {
   3005              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   3006            }
   3007            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   3008            {
   3009            }
   3010            //else ignore
   3011          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   3012          
   3013          /******************************************************************************
   3014           * @fn          ZDSecMgrSwitchKeyInd
   3015           *
   3016           * @brief       Process the ZDO_SwitchKeyInd_t message.
   3017           *
   3018           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   3019           *
   3020           * @return      none
   3021           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3022          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   3023          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3024            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??SSP_SwitchNwkKey?relay
   3025          
   3026            // Save if nv
   3027            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   ??ZDApp_NVUpdate?relay
   3028          }
   \   000014   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateInd
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateInd_t message.
   3034           *
   3035           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3040          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3041            APSME_AuthenticateReq_t req;
   3042            AddrMgrEntry_t          entry;
   3043          
   3044          
   3045            // update the address manager
   3046            //---------------------------------------------------------------------------
   3047            // note:
   3048            // required for EA processing, but ultimately EA logic could also use the
   3049            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3050            // table is supposed to have authentication states for neighbors
   3051            //---------------------------------------------------------------------------
   3052            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3053            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   EE           MOV     A,R6
   \   000017   2402         ADD     A,#0x2
   \   000019   F5..         MOV     ?V0 + 2,A
   \   00001B   EF           MOV     A,R7
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   F5..         MOV     ?V0 + 3,A
   \   000020   85..82       MOV     DPL,?V0 + 2
   \   000023   F583         MOV     DPH,A
   \   000025   12....       LCALL   ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000028   7408         MOV     A,#0x8
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   3054            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_180:
   \   000030   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   AC..         MOV     R4,?V0 + 0
   \   000035   FD           MOV     R5,A
   \   000036   740A         MOV     A,#0xa
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   AA82         MOV     R2,DPL
   \   00003D   AB83         MOV     R3,DPH
   \   00003F   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3055          
   3056            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000042                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000042   7407         MOV     A,#0x7
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   AA82         MOV     R2,DPL
   \   000049   AB83         MOV     R3,DPH
   \   00004B   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00004E   E9           MOV     A,R1
   \   00004F   6401         XRL     A,#0x1
   \   000051   7027         JNZ     ??ZDSecMgrAuthenticateInd_0
   3057            {
   3058              // set request fields
   3059              req.nwkAddr   = ind->aps.initNwkAddr;
   \   000053   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000056   12....       LCALL   ?Subroutine17 & 0xFFFF
   3060              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_124:
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   3061              req.action    = APSME_EA_ACCEPT;
   \                     ??CrossCallReturnLabel_223:
   \   00005F   7406         MOV     A,#0x6
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   7401         MOV     A,#0x1
   \   000066   F0           MOVX    @DPTR,A
   3062              req.challenge = ind->aps.challenge;
   \   000067   EE           MOV     A,R6
   \   000068   240C         ADD     A,#0xc
   \   00006A   F8           MOV     R0,A
   \   00006B   EF           MOV     A,R7
   \   00006C   3400         ADDC    A,#0x0
   \   00006E   F9           MOV     R1,A
   \   00006F   7404         MOV     A,#0x4
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   12....       LCALL   ?Subroutine0 & 0xFFFF
   3063          
   3064              // start EA processing
   3065              APSME_AuthenticateReq( &req );
   3066            }
   \                     ??CrossCallReturnLabel_2:
   \   000077   12....       LCALL   ??APSME_AuthenticateReq?relay
   3067          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   00007A   7414         MOV     A,#0x14
   \   00007C   02....       LJMP    ??Subroutine102_0 & 0xFFFF
   3068          
   3069          /******************************************************************************
   3070           * @fn          ZDSecMgrAuthenticateCfm
   3071           *
   3072           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3073           *
   3074           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3075           *
   3076           * @return      none
   3077           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3078          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3079          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3080            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV     A,R2
   \   000005   240B         ADD     A,#0xb
   \   000007   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   00000A   701F         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3081            {
   3082              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   6401         XRL     A,#0x1
   \   000015   7014         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   000017   90....       MOV     DPTR,#devState
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   6405         XRL     A,#0x5
   \   00001D   700C         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3083              {
   3084                // inform ZDO that device has been authenticated
   3085                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00001F                ; Setup parameters for call to function osal_set_event
   \   00001F   7A80         MOV     R2,#-0x80
   \   000021   7B00         MOV     R3,#0x0
   \   000023   90....       MOV     DPTR,#ZDAppTaskID
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F9           MOV     R1,A
   \   000028   12....       LCALL   ??osal_set_event?relay
   3086              }
   3087            }
   3088          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002B   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   3089          
   3090          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3091          /******************************************************************************
   3092           * @fn          ZDSecMgrUpdateNwkKey
   3093           *
   3094           * @brief       Load a new NWK key and trigger a network wide update.
   3095           *
   3096           * @param       key       - [in] new NWK key
   3097           * @param       keySeqNum - [in] new NWK key sequence number
   3098           *
   3099           * @return      ZStatus_t
   3100           */
   3101          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3102          {
   3103            ZStatus_t               status;
   3104            APSME_TransportKeyReq_t req;
   3105          
   3106            // initialize common elements of local variables
   3107            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3108              req.keyType   = KEY_TYPE_NWK_HIGH;
   3109            else
   3110              req.keyType   = KEY_TYPE_NWK;
   3111          
   3112            req.dstAddr   = dstAddr;
   3113            req.keySeqNum = keySeqNum;
   3114            req.key       = key;
   3115            req.extAddr   = NULL;
   3116            req.nwkSecure = TRUE;
   3117            req.apsSecure = TRUE;
   3118            req.tunnel    = NULL;
   3119          
   3120            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3121            {
   3122              ZDSecMgrEntry_t*        entry;
   3123              uint16                  index;
   3124              AddrMgrEntry_t          addrEntry;
   3125          
   3126              addrEntry.user = ADDRMGR_USER_SECURITY;
   3127          
   3128              status = ZFailure;
   3129          
   3130              // verify data is available
   3131              if ( ZDSecMgrEntries != NULL )
   3132              {
   3133                // find available entry
   3134                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3135                {
   3136                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3137                  {
   3138                    // return successful result
   3139                    entry = &ZDSecMgrEntries[index];
   3140          
   3141                    // get NWK address
   3142                    addrEntry.index = entry->ami;
   3143                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3144                    {
   3145                      req.dstAddr = addrEntry.nwkAddr;
   3146                      req.extAddr = addrEntry.extAddr;
   3147                      status = APSME_TransportKeyReq( &req );
   3148                    }
   3149                  }
   3150                }
   3151              }
   3152            }
   3153            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3154            {
   3155              status = APSME_TransportKeyReq( &req );
   3156            }
   3157          
   3158            SSP_UpdateNwkKey( key, keySeqNum );
   3159          
   3160            // Save if nv
   3161            ZDApp_NVUpdate();
   3162          
   3163            return status;
   3164          }
   3165          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3166          
   3167          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3168          /******************************************************************************
   3169           * @fn          ZDSecMgrSwitchNwkKey
   3170           *
   3171           * @brief       Causes the NWK key to switch via a network wide command.
   3172           *
   3173           * @param       keySeqNum - [in] new NWK key sequence number
   3174           *
   3175           * @return      ZStatus_t
   3176           */
   3177          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3178          {
   3179            ZStatus_t            status;
   3180            APSME_SwitchKeyReq_t req;
   3181          
   3182            // initialize common elements of local variables
   3183            req.dstAddr = dstAddr;
   3184            req.keySeqNum = keySeqNum;
   3185          
   3186            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3187            {
   3188              ZDSecMgrEntry_t*     entry;
   3189              uint16               index;
   3190              AddrMgrEntry_t       addrEntry;
   3191          
   3192              addrEntry.user = ADDRMGR_USER_SECURITY;
   3193          
   3194              status = ZFailure;
   3195          
   3196              // verify data is available
   3197              if ( ZDSecMgrEntries != NULL )
   3198              {
   3199                // find available entry
   3200                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3201                {
   3202                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3203                  {
   3204                    // return successful result
   3205                    entry = &ZDSecMgrEntries[index];
   3206          
   3207                    // get NWK address
   3208                    addrEntry.index = entry->ami;
   3209          
   3210                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3211                    {
   3212                      req.dstAddr = addrEntry.nwkAddr;
   3213                      status = APSME_SwitchKeyReq( &req );
   3214                    }
   3215                  }
   3216                }
   3217              }
   3218            }
   3219            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3220            {
   3221              status = APSME_SwitchKeyReq( &req );
   3222            }
   3223          
   3224            SSP_SwitchNwkKey( keySeqNum );
   3225          
   3226            // Save if nv
   3227            ZDApp_NVUpdate();
   3228          
   3229            return status;
   3230          }
   3231          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3232          
   3233          #if ( ZG_BUILD_JOINING_TYPE )
   3234          /******************************************************************************
   3235           * @fn          ZDSecMgrRequestAppKey
   3236           *
   3237           * @brief       Request an application key with partner.
   3238           *
   3239           * @param       partNwkAddr - [in] partner network address
   3240           *
   3241           * @return      ZStatus_t
   3242           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3243          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3244          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV     A,#-0xc
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   3245            ZStatus_t             status;
   3246            APSME_RequestKeyReq_t req;
   3247            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3248          
   3249          
   3250            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV     A,#0x4
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   AC82         MOV     R4,DPL
   \   000010   AD83         MOV     R5,DPH
   \   000012   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000015   E9           MOV     A,R1
   \   000016   6026         JZ      ??ZDSecMgrRequestAppKey_0
   3251            {
   3252              req.dstAddr = 0;
   \   000018   E4           CLR     A
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   F0           MOVX    @DPTR,A
   3253              req.keyType = KEY_TYPE_APP_MASTER;
   \   000020   7401         MOV     A,#0x1
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7402         MOV     A,#0x2
   \   000027   F0           MOVX    @DPTR,A
   3254              req.partExtAddr = partExtAddr;
   \   000028   7404         MOV     A,#0x4
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   A882         MOV     R0,DPL
   \   00002F   A983         MOV     R1,DPH
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   12....       LCALL   ?Subroutine0 & 0xFFFF
   3255              status = APSME_RequestKeyReq( &req );
   3256            }
   \                     ??CrossCallReturnLabel_3:
   \   000039   12....       LCALL   ??APSME_RequestKeyReq?relay
   \   00003C   8002         SJMP    ??ZDSecMgrRequestAppKey_1
   3257            else
   3258            {
   3259              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   00003E   7901         MOV     R1,#0x1
   3260            }
   3261          
   3262            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   000040   740C         MOV     A,#0xc
   \   000042   02....       LJMP    ??Subroutine110_0 & 0xFFFF
   3263          }
   3264          #endif // ( ZG_BUILD_JOINING_TYPE )
   3265          
   3266          #if ( ZG_BUILD_JOINING_TYPE )
   3267          /******************************************************************************
   3268           * @fn          ZDSecMgrSetupPartner
   3269           *
   3270           * @brief       Setup for application key partner.
   3271           *
   3272           * @param       partNwkAddr - [in] partner network address
   3273           *
   3274           * @return      ZStatus_t
   3275           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3276          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3277          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3278            AddrMgrEntry_t entry;
   3279            ZStatus_t      status;
   3280          
   3281            status = ZFailure;
   \   000012   75..01       MOV     ?V0 + 2,#0x1
   3282          
   3283            // update the address manager
   3284            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   7402         MOV     A,#0x2
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   F0           MOVX    @DPTR,A
   3285            entry.nwkAddr = partNwkAddr;
   \   00001E   7401         MOV     A,#0x1
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ?Subroutine12 & 0xFFFF
   3286            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \                     ??CrossCallReturnLabel_18:
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine50 & 0xFFFF
   3287          
   3288            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_86:
   \   00002C   7038         JNZ     ??ZDSecMgrSetupPartner_0
   3289            {
   3290              status = ZSuccess;
   \   00002E   75..00       MOV     ?V0 + 2,#0x0
   3291          
   3292              // check for address discovery
   3293              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000031   74FE         MOV     A,#-0x2
   \   000033   65..         XRL     A,?V0 + 0
   \   000035   7004         JNZ     ??ZDSecMgrSetupPartner_1
   \   000037   74FF         MOV     A,#-0x1
   \   000039   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSetupPartner_1:
   \   00003B   700F         JNZ     ??ZDSecMgrSetupPartner_2
   3294              {
   3295                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00003D                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   00003D   7D00         MOV     R5,#0x0
   \   00003F   7C00         MOV     R4,#0x0
   \   000041   7900         MOV     R1,#0x0
   \   000043   EE           MOV     A,R6
   \   000044   FA           MOV     R2,A
   \   000045   EF           MOV     A,R7
   \   000046   FB           MOV     R3,A
   \   000047   12....       LCALL   ??ZDP_NwkAddrReq?relay
   \   00004A   8017         SJMP    ??ZDSecMgrSetupPartner_3
   3296              }
   3297              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   00004C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000053   E9           MOV     A,R1
   \   000054   7010         JNZ     ??ZDSecMgrSetupPartner_0
   3298              {
   3299                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000056                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7C00         MOV     R4,#0x0
   \   00005A   7900         MOV     R1,#0x0
   \   00005C   AA..         MOV     R2,?V0 + 0
   \   00005E   AB..         MOV     R3,?V0 + 1
   \   000060   12....       LCALL   ??ZDP_IEEEAddrReq?relay
   \                     ??ZDSecMgrSetupPartner_3:
   \   000063   E9           MOV     A,R1
   \   000064   F5..         MOV     ?V0 + 2,A
   3300              }
   3301            }
   3302          
   3303            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000066   A9..         MOV     R1,?V0 + 2
   \   000068   740D         MOV     A,#0xd
   \   00006A   02....       LJMP    ?Subroutine75 & 0xFFFF
   3304          }
   3305          #endif // ( ZG_BUILD_JOINING_TYPE )
   3306          
   3307          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3308          /******************************************************************************
   3309           * @fn          ZDSecMgrAppKeyTypeSet
   3310           *
   3311           * @brief       Set application key type.
   3312           *
   3313           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3314           *                                                   KEY_TYPE_APP_LINK@3
   3315           *
   3316           * @return      ZStatus_t
   3317           */
   3318          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3319          {
   3320            if ( keyType == KEY_TYPE_APP_LINK )
   3321            {
   3322              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3323            }
   3324            else
   3325            {
   3326              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3327            }
   3328          
   3329            return ZSuccess;
   3330          }
   3331          #endif
   3332          
   3333          /******************************************************************************
   3334           * ZigBee Device Security Manager - Stub Implementations
   3335           */
   3336          /******************************************************************************
   3337           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3338           *
   3339           * @brief       Get MASTER key for specified EXT address.
   3340           *
   3341           * @param       extAddr - [in] EXT address
   3342           * @param       key     - [out] MASTER key
   3343           *
   3344           * @return      ZStatus_t
   3345           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3346          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3347          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3348            ZStatus_t status;
   3349            uint16    ami;
   3350          
   3351          
   3352            // lookup entry for specified EXT address
   3353            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   3354            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3355          
   3356            if ( status == ZSuccess )
   \   00001E   700F         JNZ     ??APSME_MasterKeyGet_0
   3357            {
   3358              ZDSecMgrMasterKeyLookup( ami, key );
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   EE           MOV     A,R6
   \   000021   FC           MOV     R4,A
   \   000022   EF           MOV     A,R7
   \   000023   FD           MOV     R5,A
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   12....       LCALL   ?Subroutine39 & 0xFFFF
   3359            }
   \                     ??CrossCallReturnLabel_67:
   \   00002D   8008         SJMP    ??APSME_MasterKeyGet_1
   3360            else
   3361            {
   3362              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E4           CLR     A
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   F0           MOVX    @DPTR,A
   3363            }
   3364          
   3365            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000037   02....       LJMP    ?Subroutine74 & 0xFFFF
   3366          }
   3367          
   3368          /******************************************************************************
   3369           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3370           *
   3371           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3372           *
   3373           * @param       extAddr - [in] EXT address
   3374           * @param       data    - [in] APSME_LinkKeyData_t
   3375           *
   3376           * @return      ZStatus_t
   3377           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3378          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3379          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3380            ZStatus_t        status;
   3381            ZDSecMgrEntry_t* entry;
   3382          
   3383          
   3384            // lookup entry index for specified EXT address
   3385            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 3,A
   3386          
   3387            if ( status == ZSuccess )
   \   00001E   704C         JNZ     ??APSME_LinkKeySet_0
   3388            {
   3389              // setup the link key data reference
   3390              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   000020                ; Setup parameters for call to function osal_memcpy
   \   000020   8E..         MOV     ?V0 + 0,R6
   \   000022   8F..         MOV     ?V0 + 1,R7
   \   000024   75..00       MOV     ?V0 + 2,#0x0
   \   000027   78..         MOV     R0,#?V0 + 0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00002C   7C10         MOV     R4,#0x10
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   7403         MOV     A,#0x3
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000038   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   3391          
   3392              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   00003E   90....       MOV     DPTR,#__Constant_0
   \   000041   78..         MOV     R0,#?V0 + 4
   \   000043   12....       LCALL   ?L_MOV_X
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   2418         ADD     A,#0x18
   \   00004F   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000052   12....       LCALL   ?L_MOV_TO_X
   3393              entry->lkd.apsmelkd.txFrmCntr = 0;
   \   000055   90....       MOV     DPTR,#__Constant_0
   \   000058   78..         MOV     R0,#?V0 + 4
   \   00005A   12....       LCALL   ?L_MOV_X
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   2414         ADD     A,#0x14
   \   000066   12....       LCALL   ?Subroutine34 & 0xFFFF
   3394            }
   \                     ??CrossCallReturnLabel_58:
   \   000069   12....       LCALL   ?L_MOV_TO_X
   3395          
   3396            return status;
   \                     ??APSME_LinkKeySet_0:
   \   00006C   A9..         MOV     R1,?V0 + 3
   \   00006E   7402         MOV     A,#0x2
   \   000070                REQUIRE ?Subroutine78
   \   000070                ; // Fall through to label ?Subroutine78
   3397          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2402         ADD     A,#0x2
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3398          
   3399          /******************************************************************************
   3400           * @fn          ZDSecMgrAuthenticationSet
   3401           *
   3402           * @brief       Mark the specific device as authenticated or not
   3403           *
   3404           * @param       extAddr - [in] EXT address
   3405           * @param       option  - [in] authenticated or not
   3406           *
   3407           * @return      ZStatus_t
   3408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3409          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3410          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3411            ZStatus_t        status;
   3412            ZDSecMgrEntry_t* entry;
   3413          
   3414          
   3415            // lookup entry index for specified EXT address
   3416            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   AC82         MOV     R4,DPL
   \   000014   AD83         MOV     R5,DPH
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000019   E9           MOV     A,R1
   3417          
   3418            if ( status == ZSuccess )
   \   00001A   7015         JNZ     ??ZDSecMgrAuthenticationSet_0
   3419            {
   3420              entry->authenticateOption = option;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   241C         ADD     A,#0x1c
   \   000025   FA           MOV     R2,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   3400         ADDC    A,#0x0
   \   00002A   FB           MOV     R3,A
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   EE           MOV     A,R6
   \   000030   F0           MOVX    @DPTR,A
   3421            }
   3422          
   3423            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000031   02....       LJMP    ??Subroutine94_0 & 0xFFFF
   3424          }
   3425          
   3426          /******************************************************************************
   3427           * @fn          ZDSecMgrAuthenticationCheck
   3428           *
   3429           * @brief       Check if the specific device has been authenticated or not
   3430           *              For non-trust center device, always return true
   3431           *
   3432           * @param       shortAddr - [in] short address
   3433           *
   3434           * @return      TRUE @ authenticated with CBKE
   3435           *              FALSE @ not authenticated
   3436           */
   3437          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3438          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3439          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3440          #if defined (TC_LINKKEY_JOIN)
   3441          
   3442            ZDSecMgrEntry_t* entry;
   3443            uint8 extAddr[Z_EXTADDR_LEN];
   3444          
   3445            // If the local device is not the trust center, always return TRUE
   3446            if ( NLME_GetShortAddr() != TCshortAddr )
   3447            {
   3448              return TRUE;
   3449            }
   3450            // Otherwise, check the authentication option
   3451            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3452            {
   3453              // lookup entry index for specified EXT address
   3454              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3455              {
   3456                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3457                {
   3458                  return TRUE;
   3459                }
   3460                else
   3461                {
   3462                  return FALSE;
   3463                }
   3464              }
   3465            }
   3466            return FALSE;
   3467          
   3468          #else
   3469            (void)shortAddr;  // Intentionally unreferenced parameter
   3470            
   3471            // For non AMI/SE Profile, perform no check and always return true.
   3472            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3473          
   3474          #endif // TC_LINKKEY_JOIN
   3475          }
   3476          
   3477          
   3478          /******************************************************************************
   3479           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3480           *
   3481           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3482           *
   3483           * @param       extAddr - [in] EXT address
   3484           * @param       data    - [out] APSME_LinkKeyData_t
   3485           *
   3486           * @return      ZStatus_t
   3487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3488          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3489          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3490            ZStatus_t        status;
   3491            ZDSecMgrEntry_t* entry;
   3492          
   3493          
   3494            // lookup entry index for specified NWK address
   3495            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   3496          
   3497            if ( status == ZSuccess )
   \   00001C   702C         JNZ     ??APSME_LinkKeyDataGet_0
   3498            {
   3499              // setup the link key data reference
   3500              (*data) = &entry->lkd.apsmelkd;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   2412         ADD     A,#0x12
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   3400         ADDC    A,#0x0
   \   00002C   FB           MOV     R3,A
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   12....       LCALL   ?Subroutine13 & 0xFFFF
   3501              (*data)->key = entry->lkd.key;
   \                     ??CrossCallReturnLabel_25:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   12....       LCALL   ?Subroutine42 & 0xFFFF
   3502            }
   \                     ??CrossCallReturnLabel_71:
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000044   EA           MOV     A,R2
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   EB           MOV     A,R3
   \   000048   8007         SJMP    ??APSME_LinkKeyDataGet_1
   3503            else
   3504            {
   3505              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   E4           CLR     A
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \                     ??APSME_LinkKeyDataGet_1:
   \   000051   F0           MOVX    @DPTR,A
   3506            }
   3507          
   3508            return status;
   \   000052   02....       LJMP    ??Subroutine94_0 & 0xFFFF
   3509          }
   3510          
   3511          /******************************************************************************
   3512           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3513           *
   3514           * @brief       Verify and process key transportation to child.
   3515           *
   3516           * @param       ind - [in] APSME_TransportKeyInd_t
   3517           *
   3518           * @return      uint8 - success(TRUE:FALSE)
   3519           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3520          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3521          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3522            uint8 success;
   3523          
   3524            success = FALSE;
   \   000005   7E00         MOV     R6,#0x0
   3525          
   3526            // verify from Trust Center
   3527            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   7002         JNZ     ??APSME_KeyFwdToChild_0
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \                     ??APSME_KeyFwdToChild_0:
   \   000010   7027         JNZ     ??APSME_KeyFwdToChild_1
   3528            {
   3529              success = TRUE;
   \   000012   0E           INC     R6
   3530          
   3531              // check for initial NWK key
   3532              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3533                   ( ind->keyType == 6                 ) ||
   3534                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FC           MOV     R4,A
   \   00001B   EE           MOV     A,R6
   \   00001C   6C           XRL     A,R4
   \   00001D   600A         JZ      ??APSME_KeyFwdToChild_2
   \   00001F   7406         MOV     A,#0x6
   \   000021   6C           XRL     A,R4
   \   000022   6005         JZ      ??APSME_KeyFwdToChild_2
   \   000024   7405         MOV     A,#0x5
   \   000026   6C           XRL     A,R4
   \   000027   7010         JNZ     ??APSME_KeyFwdToChild_1
   3535              {
   3536                // set association status to authenticated
   3537                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_2:
   \   000029                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000029                ; Setup parameters for call to function AssocGetWithExt
   \   000029   8A82         MOV     DPL,R2
   \   00002B   8B83         MOV     DPH,R3
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   12....       LCALL   ?Subroutine40 & 0xFFFF
   3538              }
   3539            }
   \                     ??CrossCallReturnLabel_69:
   \   000036   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3540          
   3541            return success;
   \                     ??APSME_KeyFwdToChild_1:
   \   000039   EE           MOV     A,R6
   \   00003A   F9           MOV     R1,A
   \   00003B   02....       LJMP    ??Subroutine96_0 & 0xFFFF
   3542          }
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrAddLinkKey
   3546           *
   3547           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3548           *              as authenticated in the authenticateOption. Note that this function
   3549           *              is hardwared to CBKE right now.
   3550           *
   3551           * @param       shortAddr - short address of the partner device
   3552           * @param       extAddr - extended address of the partner device
   3553           * @param       key - link key
   3554           *
   3555           * @return      ZStatus_t
   3556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3557          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3558          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   7410         MOV     A,#0x10
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   3559            uint16           ami;
   3560            ZDSecMgrEntry_t* entry;
   3561          
   3562            /* Store the device address in the addr manager */
   3563            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000032   E9           MOV     A,R1
   \   000033   6004         JZ      ??ZDSecMgrAddLinkKey_0
   3564            {
   3565              /* Adding to Addr Manager fails */
   3566              return ZFailure;
   \   000035   7901         MOV     R1,#0x1
   \   000037   804F         SJMP    ??ZDSecMgrAddLinkKey_1
   3567            }
   3568          
   3569            /* Lookup entry using specified address index */
   3570            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000039                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   AC82         MOV     R4,DPL
   \   000041   AD83         MOV     R5,DPH
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ?Subroutine35 & 0xFFFF
   3571          
   3572            // If no existing entry, create one
   3573            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_60:
   \   00004B   85..82       MOV     DPL,?XSP + 0
   \   00004E   85..83       MOV     DPH,?XSP + 1
   \   000051   E0           MOVX    A,@DPTR
   \   000052   7002         JNZ     ??ZDSecMgrAddLinkKey_2
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000056   7023         JNZ     ??CrossCallReturnLabel_181
   3574            {
   3575              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000058                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   AA82         MOV     R2,DPL
   \   000060   AB83         MOV     R3,DPH
   \   000062   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000065   E9           MOV     A,R1
   \   000066   7023         JNZ     ??ZDSecMgrAddLinkKey_3
   3576              {
   3577                entry->ami = ami;
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   12....       LCALL   ?Subroutine32 & 0xFFFF
   3578              }
   \                     ??CrossCallReturnLabel_154:
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FA           MOV     R2,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   F583         MOV     DPH,A
   \   000076   8A82         MOV     DPL,R2
   \   000078   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   3579              else
   3580              {
   3581                /* Security Manager full */
   3582                return ZBufferFull;
   3583              }
   3584            }
   3585            // Write the link key
   3586            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_181:
   \   00007B                ; Setup parameters for call to function APSME_LinkKeySet
   \   00007B   AC..         MOV     R4,?V0 + 0
   \   00007D   AD..         MOV     R5,?V0 + 1
   \   00007F   EE           MOV     A,R6
   \   000080   FA           MOV     R2,A
   \   000081   EF           MOV     A,R7
   \   000082   FB           MOV     R3,A
   \   000083   12....       LCALL   ??APSME_LinkKeySet?relay
   3587          
   3588          #if defined (TC_LINKKEY_JOIN)
   3589            // Mark the device as authenticated.
   3590            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3591          #endif
   3592          
   3593          #if defined NV_RESTORE
   3594            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3595          #endif
   3596            
   3597            return ZSuccess;
   \   000086   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000088   02....       LJMP    ?Subroutine77 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_3:
   \   00008B   7911         MOV     R1,#0x11
   \   00008D   80F9         SJMP    ??ZDSecMgrAddLinkKey_1
   3598          }
   3599          
   3600          #if defined ( NV_RESTORE )
   3601          /******************************************************************************
   3602           * @fn          ZDSecMgrInitNV
   3603           *
   3604           * @brief       Initialize the SecMgr entry data in NV.
   3605           *
   3606           * @param       none
   3607           *
   3608           * @return      uint8 - <osal_nv_item_init> return codes
   3609           */
   3610          uint8 ZDSecMgrInitNV(void)
   3611          {
   3612            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3613                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3614            if (rtrn != ZSUCCESS)  // If the item does not already exist.
   3615            {
   3616              nvDeviceListHdr_t hdr;
   3617              hdr.numRecs = 0;
   3618              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3619            }
   3620          
   3621            return rtrn;
   3622          }
   3623          #endif // NV_RESTORE
   3624          
   3625          #if defined ( NV_RESTORE )
   3626          /*********************************************************************
   3627           * @fn      ZDSecMgrWriteNV()
   3628           *
   3629           * @brief   Save off the link key list to NV
   3630           *
   3631           * @param   none
   3632           *
   3633           * @return  none
   3634           */
   3635          static void ZDSecMgrWriteNV( void )
   3636          {
   3637            uint16 i;
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            hdr.numRecs = 0;
   3641          
   3642            if (ZDSecMgrEntries != NULL)
   3643            {
   3644              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3645              {
   3646                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3647                {
   3648                  // Save off the record
   3649                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3650                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3651                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3652                  hdr.numRecs++;
   3653                }
   3654              }
   3655            }
   3656          
   3657            // Save off the header
   3658            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3659          }
   3660          #endif // NV_RESTORE
   3661          
   3662          #if defined ( NV_RESTORE )
   3663          /******************************************************************************
   3664           * @fn          ZDSecMgrRestoreFromNV
   3665           *
   3666           * @brief       Restore the SecMgr entry data from NV.
   3667           *
   3668           * @param       none
   3669           *
   3670           * @return      None.
   3671           */
   3672          static void ZDSecMgrRestoreFromNV( void )
   3673          {
   3674            nvDeviceListHdr_t hdr;
   3675          
   3676            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3677                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3678            {
   3679              uint8 x;
   3680          
   3681              for (x = 0; x < hdr.numRecs; x++)
   3682              {
   3683                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3684                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3685                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3686                {
   3687                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3688                }
   3689              }
   3690            }
   3691          }
   3692          #endif // NV_RESTORE
   3693          
   3694          /******************************************************************************
   3695           * @fn          ZDSecMgrAPSRemove
   3696           *
   3697           * @brief       Remove device from network.
   3698           *
   3699           * @param       nwkAddr - device's NWK address
   3700           * @param       extAddr - device's Extended address
   3701           * @param       parentAddr - parent's NWK address
   3702           *
   3703           * @return      ZStatus_t
   3704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3705          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3706          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   \   000009   740A         MOV     A,#0xa
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ??Subroutine104_0 & 0xFFFF
   3707            ZDSecMgrDevice_t device;
   3708          
   3709            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3710                 ( extAddr == NULL )              ||
   3711                 ( parentAddr == INVALID_NODE_ADDR ) )
   \                     ??CrossCallReturnLabel_165:
   \   000011   74FE         MOV     A,#-0x2
   \   000013   6A           XRL     A,R2
   \   000014   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   000016   74FF         MOV     A,#-0x1
   \   000018   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000019   6010         JZ      ??ZDSecMgrAPSRemove_1
   \   00001B   EC           MOV     A,R4
   \   00001C   7001         JNZ     ??ZDSecMgrAPSRemove_2
   \   00001E   ED           MOV     A,R5
   \                     ??ZDSecMgrAPSRemove_2:
   \   00001F   600A         JZ      ??ZDSecMgrAPSRemove_1
   \   000021   74FE         MOV     A,#-0x2
   \   000023   68           XRL     A,R0
   \   000024   7003         JNZ     ??ZDSecMgrAPSRemove_3
   \   000026   74FF         MOV     A,#-0x1
   \   000028   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_3:
   \   000029   7004         JNZ     ??ZDSecMgrAPSRemove_4
   3712            {
   3713              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   8020         SJMP    ??ZDSecMgrAPSRemove_5
   3714            }
   3715          
   3716            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_4:
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   12....       LCALL   ?Subroutine13 & 0xFFFF
   3717            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_26:
   \   000038   7402         MOV     A,#0x2
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   EC           MOV     A,R4
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   ED           MOV     A,R5
   \   000041   F0           MOVX    @DPTR,A
   3718            device.parentAddr = parentAddr;
   \   000042   7404         MOV     A,#0x4
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ?Subroutine0 & 0xFFFF
   3719          
   3720            // remove device
   3721            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_4:
   \   00004A   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3722          
   3723            return ( ZSuccess );
   \   00004D   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_5:
   \   00004F   02....       LJMP    ?Subroutine84 & 0xFFFF
   3724          }
   3725          
   3726          /******************************************************************************
   3727           * @fn          APSME_TCLinkKeyInit
   3728           *
   3729           * @brief       Initialize the NV table for preconfigured TC link key
   3730           *               
   3731           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3732           *              Trust Center Link Key is written to NV. A single tclk is used   
   3733           *              by all devices joining the network.
   3734           *              
   3735           * @param       none
   3736           *
   3737           * @return      none
   3738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3739          void APSME_TCLinkKeyInit(void)
   \                     APSME_TCLinkKeyInit:
   3740          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3741            uint8             i;
   3742            APSME_TCLinkKey_t tcLinkKey;
   3743            
   3744            // Initialize all NV items for preconfigured tclk with 
   3745            // extended address all zero, if not exist already.
   3746            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV     R4,#0x20
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??osal_memset?relay
   3747            for( i = 1; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3748            {
   3749              osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3750                                 sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   3751            }
   3752            
   3753            // Initialize the default tclk
   3754            if( zgUseDefaultTCLK == TRUE )
   \   00001D   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6401         XRL     A,#0x1
   \   000023   7034         JNZ     ??APSME_TCLinkKeyInit_0
   3755            {
   3756              osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000025                ; Setup parameters for call to function osal_memset
   \   000025   7C08         MOV     R4,#0x8
   \   000027   7D00         MOV     R5,#0x0
   \   000029   79FF         MOV     R1,#-0x1
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   \   000035   12....       LCALL   ??osal_memset?relay
   3757              osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   000038                ; Setup parameters for call to function osal_memcpy
   \   000038   75....       MOV     ?V0 + 0,#(defaultTCLinkKey & 0xff)
   \   00003B   75....       MOV     ?V0 + 1,#((defaultTCLinkKey >> 8) & 0xff)
   \   00003E   75..80       MOV     ?V0 + 2,#-0x80
   \   000041   78..         MOV     R0,#?V0 + 0
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000046   7C10         MOV     R4,#0x10
   \   000048   7D00         MOV     R5,#0x0
   \   00004A   740B         MOV     A,#0xb
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   AA82         MOV     R2,DPL
   \   000051   AB83         MOV     R3,DPH
   \   000053   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
   3758              
   3759              // If the item doesn't exist in NV memory, create and initialize
   3760              // it with the default value passed in.
   3761              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000059                ; Setup parameters for call to function osal_nv_item_init
   3762            }
   3763            else
   3764            {
   3765              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_0:
   \   000059                ; Setup parameters for call to function osal_nv_item_init
   \   000059   85..82       MOV     DPL,?XSP + 0
   \   00005C   85..83       MOV     DPH,?XSP + 1
   \   00005F   8582..       MOV     ?V0 + 0,DPL
   \   000062   8583..       MOV     ?V0 + 1,DPH
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   7C20         MOV     R4,#0x20
   \   00006C   7D00         MOV     R5,#0x0
   \   00006E   7A01         MOV     R2,#0x1
   \   000070   7B01         MOV     R3,#0x1
   \   000072   12....       LCALL   ??osal_nv_item_init?relay
   \   000075   7402         MOV     A,#0x2
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   3766            }
   3767          }
   \   00007A   7420         MOV     A,#0x20
   \   00007C   02....       LJMP    ?Subroutine75 & 0xFFFF
   3768          
   3769          /******************************************************************************
   3770           * @fn          APSME_TCLinkKeySync
   3771           *
   3772           * @brief       Sync Trust Center LINK key data.
   3773           *
   3774           * @param       srcAddr - [in] srcAddr
   3775           * @param       si      - [in, out] SSP_Info_t
   3776           *
   3777           * @return      ZStatus_t
   3778           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3779          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3780          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3781            ZStatus_t          status = ZSecNoKey;
   3782            uint8              i;
   3783            APSME_TCLinkKey_t  tcLinkKey;       
   3784            
   3785            // Look up the IEEE address of the trust center if it's available
   3786            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   000012   EE           MOV     A,R6
   \   000013   2406         ADD     A,#0x6
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   EF           MOV     A,R7
   \   000018   3400         ADDC    A,#0x0
   \   00001A   F5..         MOV     ?V0 + 1,A
   \   00001C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001C   AA..         MOV     R2,?V0 + 0
   \   00001E   FB           MOV     R3,A
   \   00001F   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000022   E9           MOV     A,R1
   \   000023   700B         JNZ     ??APSME_TCLinkKeySync_0
   3787            {
   3788              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000025                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000025   AC..         MOV     R4,?V0 + 0
   \   000027   AD..         MOV     R5,?V0 + 1
   \   000029   AA..         MOV     R2,?V0 + 2
   \   00002B   AB..         MOV     R3,?V0 + 3
   \   00002D   12....       LCALL   ??APSME_LookupExtAddr?relay
   3789            }
   3790            
   3791            // Look up the TC link key associated with the device
   3792            // or the default TC link key (extAddr is all FFs), whichever is found
   3793            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3794            {
   3795              // Read entry i of the TC link key table from NV
   3796              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3797                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_0:
   \   000030                ; Setup parameters for call to function osal_nv_read
   \   000030   85..82       MOV     DPL,?XSP + 0
   \   000033   85..83       MOV     DPH,?XSP + 1
   \   000036   8582..       MOV     ?V0 + 2,DPL
   \   000039   8583..       MOV     ?V0 + 3,DPH
   \   00003C   78..         MOV     R0,#?V0 + 2
   \   00003E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000041   75..20       MOV     ?V0 + 2,#0x20
   \   000044   75..00       MOV     ?V0 + 3,#0x0
   \   000047   78..         MOV     R0,#?V0 + 2
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004C   7C00         MOV     R4,#0x0
   \   00004E   7D00         MOV     R5,#0x0
   \   000050   7A01         MOV     R2,#0x1
   \   000052   7B01         MOV     R3,#0x1
   \   000054   12....       LCALL   ??osal_nv_read?relay
   \   000057   7404         MOV     A,#0x4
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   3798              
   3799              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3800                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00005C                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   AC82         MOV     R4,DPL
   \   000064   AD83         MOV     R5,DPH
   \   000066   AA..         MOV     R2,?V0 + 0
   \   000068   AB..         MOV     R3,?V0 + 1
   \   00006A   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   00006D   E9           MOV     A,R1
   \   00006E   7013         JNZ     ??APSME_TCLinkKeySync_1
   \   000070                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000070   85..82       MOV     DPL,?XSP + 0
   \   000073   85..83       MOV     DPH,?XSP + 1
   \   000076   AA82         MOV     R2,DPL
   \   000078   AB83         MOV     R3,DPH
   \   00007A   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   00007D   E9           MOV     A,R1
   \   00007E   7003         JNZ     $+5
   \   000080   02....       LJMP    ??APSME_TCLinkKeySync_2 & 0xFFFF
   3801              {
   3802                // verify that the incoming frame counter is valid
   3803                if ( si->frmCntr >= tcLinkKey.rxFrmCntr )
   \                     ??APSME_TCLinkKeySync_1:
   \   000083   EE           MOV     A,R6
   \   000084   2412         ADD     A,#0x12
   \   000086   F5..         MOV     ?V0 + 0,A
   \   000088   EF           MOV     A,R7
   \   000089   3400         ADDC    A,#0x0
   \   00008B   F5..         MOV     ?V0 + 1,A
   \   00008D   85..82       MOV     DPL,?V0 + 0
   \   000090   F583         MOV     DPH,A
   \   000092   C082         PUSH    DPL
   \   000094   C083         PUSH    DPH
   \   000096   741C         MOV     A,#0x1c
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   78..         MOV     R0,#?V0 + 4
   \   00009D   12....       LCALL   ?L_MOV_X
   \   0000A0   D083         POP     DPH
   \   0000A2   D082         POP     DPL
   \   0000A4   78..         MOV     R0,#?V0 + 4
   \   0000A6   12....       LCALL   ?UL_GT_X
   \   0000A9   407A         JC      ??APSME_TCLinkKeySync_3
   3804                {
   3805                  // set the key to use
   3806                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN );
   \   0000AB                ; Setup parameters for call to function osal_memcpy
   \   0000AB   7408         MOV     A,#0x8
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   A982         MOV     R1,DPL
   \   0000B2   AA83         MOV     R2,DPH
   \   0000B4   89..         MOV     ?V0 + 4,R1
   \   0000B6   8A..         MOV     ?V0 + 5,R2
   \   0000B8   75..00       MOV     ?V0 + 6,#0x0
   \   0000BB   78..         MOV     R0,#?V0 + 4
   \   0000BD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000C0   7C10         MOV     R4,#0x10
   \   0000C2   7D00         MOV     R5,#0x0
   \   0000C4   EE           MOV     A,R6
   \   0000C5   240F         ADD     A,#0xf
   \   0000C7   F582         MOV     DPL,A
   \   0000C9   EF           MOV     A,R7
   \   0000CA   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   0000CD   12....       LCALL   ?DEALLOC_XSTACK8
   3807                  
   3808                  // update the rx frame counter
   3809                  tcLinkKey.rxFrmCntr = si->frmCntr + 1;
   \   0000D0   85..82       MOV     DPL,?V0 + 0
   \   0000D3   85..83       MOV     DPH,?V0 + 1
   \   0000D6   C082         PUSH    DPL
   \   0000D8   C083         PUSH    DPH
   \   0000DA   90....       MOV     DPTR,#__Constant_1
   \   0000DD   78..         MOV     R0,#?V0 + 0
   \   0000DF   12....       LCALL   ?L_MOV_X
   \   0000E2   D083         POP     DPH
   \   0000E4   D082         POP     DPL
   \   0000E6   78..         MOV     R0,#?V0 + 0
   \   0000E8   12....       LCALL   ?L_ADD_X
   \   0000EB   741C         MOV     A,#0x1c
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   78..         MOV     R0,#?V0 + 0
   \   0000F2   12....       LCALL   ?L_MOV_TO_X
   3810                  
   3811                  // Write the tc link key back to the NV
   3812                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3813                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000F5                ; Setup parameters for call to function osal_nv_write
   \   0000F5   85..82       MOV     DPL,?XSP + 0
   \   0000F8   85..83       MOV     DPH,?XSP + 1
   \   0000FB   8582..       MOV     ?V0 + 0,DPL
   \   0000FE   8583..       MOV     ?V0 + 1,DPH
   \   000101   78..         MOV     R0,#?V0 + 0
   \   000103   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000106   75..20       MOV     ?V0 + 0,#0x20
   \   000109   75..00       MOV     ?V0 + 1,#0x0
   \   00010C   78..         MOV     R0,#?V0 + 0
   \   00010E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000111   7C00         MOV     R4,#0x0
   \   000113   7D00         MOV     R5,#0x0
   \   000115   7A01         MOV     R2,#0x1
   \   000117   7B01         MOV     R3,#0x1
   \   000119   12....       LCALL   ??osal_nv_write?relay
   \   00011C   7404         MOV     A,#0x4
   \   00011E   12....       LCALL   ?DEALLOC_XSTACK8
   3814                  
   3815                  status = ZSuccess;
   \   000121   7900         MOV     R1,#0x0
   \   000123   8006         SJMP    ??APSME_TCLinkKeySync_4
   3816                  
   3817                }
   3818                else
   3819                {
   3820                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_3:
   \   000125   79A2         MOV     R1,#-0x5e
   3821                }
   3822                
   3823                return status;
   \   000127   8002         SJMP    ??APSME_TCLinkKeySync_4
   3824              }
   3825            }
   3826            
   3827            
   3828            return status;
   \                     ??APSME_TCLinkKeySync_2:
   \   000129   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeySync_4:
   \   00012B   7420         MOV     A,#0x20
   \   00012D   02....       LJMP    ?Subroutine78 & 0xFFFF
   3829          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   000003                REQUIRE ??Subroutine114_0
   \   000003                ; // Fall through to label ??Subroutine114_0
   3830          
   3831          /******************************************************************************
   3832           * @fn          APSME_TCLinkKeyLoad
   3833           *
   3834           * @brief       Load Trust Center LINK key data.
   3835           *
   3836           * @param       dstAddr - [in] dstAddr
   3837           * @param       si      - [in, out] SSP_Info_t
   3838           *
   3839           * @return      ZStatus_t
   3840           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   F582         MOV     DPL,A
   \   000002   E5..         MOV     A,?V0 + 1
   \   000004                REQUIRE ??Subroutine111_0
   \   000004                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3841          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3842          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   3843            uint8              i;
   3844            APSME_TCLinkKey_t  tcLinkKey;
   3845            AddrMgrEntry_t     addrEntry;  
   3846            
   3847            // Look up the ami of the srcAddr if available
   3848            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   E4           CLR     A
   \   00000F   85..82       MOV     DPL,?XSP + 0
   \   000012   85..83       MOV     DPH,?XSP + 1
   \   000015   F0           MOVX    @DPTR,A
   3849            addrEntry.nwkAddr = dstAddr;
   \   000016   7401         MOV     A,#0x1
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine13 & 0xFFFF
   3850          
   3851            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \                     ??CrossCallReturnLabel_27:
   \   00001E   EC           MOV     A,R4
   \   00001F   2406         ADD     A,#0x6
   \   000021   FE           MOV     R6,A
   \   000022   ED           MOV     A,R5
   \   000023   3400         ADDC    A,#0x0
   \   000025   FF           MOV     R7,A
   \   000026                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000026   EE           MOV     A,R6
   \   000027   FC           MOV     R4,A
   \   000028   EF           MOV     A,R7
   \   000029   FD           MOV     R5,A
   \   00002A   12....       LCALL   ??APSME_LookupExtAddr?relay
   3852          
   3853            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   00002D                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002D   EE           MOV     A,R6
   \   00002E   FA           MOV     R2,A
   \   00002F   EF           MOV     A,R7
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   6003         JZ      $+5
   \   000039   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3854            {
   3855              // Look up the TC link key associated with the device
   3856              // or the master TC link key (ami = 0xFFFF), whichever is found
   3857              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3858              {
   3859                // Read entry i of the TC link key table from NV
   3860                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3861                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00003C                ; Setup parameters for call to function osal_nv_read
   \   00003C   740D         MOV     A,#0xd
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   8582..       MOV     ?V0 + 2,DPL
   \   000044   8583..       MOV     ?V0 + 3,DPH
   \   000047   78..         MOV     R0,#?V0 + 2
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004C   75..20       MOV     ?V0 + 2,#0x20
   \   00004F   75..00       MOV     ?V0 + 3,#0x0
   \   000052   78..         MOV     R0,#?V0 + 2
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   7C00         MOV     R4,#0x0
   \   000059   7D00         MOV     R5,#0x0
   \   00005B   7A01         MOV     R2,#0x1
   \   00005D   7B01         MOV     R3,#0x1
   \   00005F   12....       LCALL   ??osal_nv_read?relay
   \   000062   7404         MOV     A,#0x4
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   3862                
   3863                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3864                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000067                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000067   740D         MOV     A,#0xd
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   AC82         MOV     R4,DPL
   \   00006E   AD83         MOV     R5,DPH
   \   000070   EE           MOV     A,R6
   \   000071   FA           MOV     R2,A
   \   000072   EF           MOV     A,R7
   \   000073   FB           MOV     R3,A
   \   000074   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000077   E9           MOV     A,R1
   \   000078   7012         JNZ     ??APSME_TCLinkKeyLoad_1
   \   00007A                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00007A   740D         MOV     A,#0xd
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   AA82         MOV     R2,DPL
   \   000081   AB83         MOV     R3,DPH
   \   000083   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   000086   E9           MOV     A,R1
   \   000087   7003         JNZ     $+5
   \   000089   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3865                {
   3866                  // set the key to use
   3867                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN);  
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00008C                ; Setup parameters for call to function osal_memcpy
   \   00008C   7415         MOV     A,#0x15
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   A982         MOV     R1,DPL
   \   000093   AA83         MOV     R2,DPH
   \   000095   89..         MOV     ?V0 + 4,R1
   \   000097   8A..         MOV     ?V0 + 5,R2
   \   000099   75..00       MOV     ?V0 + 6,#0x0
   \   00009C   78..         MOV     R0,#?V0 + 4
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000A1   7C10         MOV     R4,#0x10
   \   0000A3   7D00         MOV     R5,#0x0
   \   0000A5   E5..         MOV     A,?V0 + 0
   \   0000A7   240F         ADD     A,#0xf
   \   0000A9   F582         MOV     DPL,A
   \   0000AB   E5..         MOV     A,?V0 + 1
   \   0000AD   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   0000B0   12....       LCALL   ?DEALLOC_XSTACK8
   3868                  
   3869                  // update link key related fields
   3870                  si->keyID   = SEC_KEYID_LINK;
   \   0000B3   E5..         MOV     A,?V0 + 0
   \   0000B5   240E         ADD     A,#0xe
   \   0000B7   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   3871                  si->frmCntr = tcLinkKey.txFrmCntr;
   \   0000BC   7425         MOV     A,#0x25
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   78..         MOV     R0,#?V0 + 4
   \   0000C3   12....       LCALL   ?L_MOV_X
   \   0000C6   E5..         MOV     A,?V0 + 0
   \   0000C8   2412         ADD     A,#0x12
   \   0000CA   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?L_MOV_TO_X
   3872                
   3873                  // update outgoing frame counter
   3874                  tcLinkKey.txFrmCntr++;
   \   0000D2   90....       MOV     DPTR,#__Constant_1
   \   0000D5   78..         MOV     R0,#?V0 + 0
   \   0000D7   12....       LCALL   ?L_MOV_X
   \   0000DA   7425         MOV     A,#0x25
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   78..         MOV     R0,#?V0 + 0
   \   0000E1   12....       LCALL   ?L_ADD_TO_X
   3875                  
   3876                  // Write the tc link key back to the NV
   3877                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3878                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000E4                ; Setup parameters for call to function osal_nv_write
   \   0000E4   740D         MOV     A,#0xd
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   8582..       MOV     ?V0 + 0,DPL
   \   0000EC   8583..       MOV     ?V0 + 1,DPH
   \   0000EF   78..         MOV     R0,#?V0 + 0
   \   0000F1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F4   75..20       MOV     ?V0 + 0,#0x20
   \   0000F7   75..00       MOV     ?V0 + 1,#0x0
   \   0000FA   78..         MOV     R0,#?V0 + 0
   \   0000FC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FF   7C00         MOV     R4,#0x0
   \   000101   7D00         MOV     R5,#0x0
   \   000103   7A01         MOV     R2,#0x1
   \   000105   7B01         MOV     R3,#0x1
   \   000107   12....       LCALL   ??osal_nv_write?relay
   \   00010A   7404         MOV     A,#0x4
   \   00010C   12....       LCALL   ?DEALLOC_XSTACK8
   3879                  
   3880                  return ZSuccess;
   \   00010F   7900         MOV     R1,#0x0
   \   000111   8021         SJMP    ??APSME_TCLinkKeyLoad_2
   3881                }
   3882              }
   3883            }
   3884              
   3885            // If no TC link key found, remove the device from the address manager
   3886            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   000113                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000113   85..82       MOV     DPL,?XSP + 0
   \   000116   85..83       MOV     DPH,?XSP + 1
   \   000119   AA82         MOV     R2,DPL
   \   00011B   AB83         MOV     R3,DPH
   \   00011D   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000120   E9           MOV     A,R1
   \   000121   6401         XRL     A,#0x1
   \   000123   700D         JNZ     ??APSME_TCLinkKeyLoad_3
   3887            {
   3888              AddrMgrEntryRelease( &addrEntry );
   \   000125                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000125   85..82       MOV     DPL,?XSP + 0
   \   000128   85..83       MOV     DPH,?XSP + 1
   \   00012B   AA82         MOV     R2,DPL
   \   00012D   AB83         MOV     R3,DPH
   \   00012F   12....       LCALL   ??AddrMgrEntryRelease?relay
   3889            }
   3890          
   3891            return ZSecNoKey;
   \                     ??APSME_TCLinkKeyLoad_3:
   \   000132   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_2:
   \   000134   742D         MOV     A,#0x2d
   \   000136   02....       LJMP    ?Subroutine78 & 0xFFFF
   3892          }
   3893          
   3894          /******************************************************************************
   3895           * @fn          APSME_IsDefaultTCLK
   3896           *
   3897           * @brief       Return true or false based on the extended address.  If the 
   3898           *              input ext address is all FFs, it means the trust center link
   3899           *              assoiciated with the address is the default trust center link key
   3900           *
   3901           * @param       extAddr - [in] extended address
   3902           *
   3903           * @return      uint8 TRUE/FALSE
   3904           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3905          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   3906          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3907            uint8 i = 0;
   \   000004   7C00         MOV     R4,#0x0
   3908            
   3909            if( extAddr == NULL )
   \   000006   EA           MOV     A,R2
   \   000007   7001         JNZ     ??APSME_IsDefaultTCLK_0
   \   000009   EB           MOV     A,R3
   \                     ??APSME_IsDefaultTCLK_0:
   \   00000A   701A         JNZ     ??APSME_IsDefaultTCLK_1
   3910            {
   3911              return FALSE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   801F         SJMP    ??APSME_IsDefaultTCLK_3
   3912            }
   3913            
   3914            while( i++ < Z_EXTADDR_LEN )
   3915            {
   3916              if( *extAddr++ != 0xFF )
   \                     ??APSME_IsDefaultTCLK_4:
   \   000010   EA           MOV     A,R2
   \   000011   F8           MOV     R0,A
   \   000012   EB           MOV     A,R3
   \   000013   F9           MOV     R1,A
   \   000014   8882         MOV     DPL,R0
   \   000016   8983         MOV     DPH,R1
   \   000018   A3           INC     DPTR
   \   000019   AA82         MOV     R2,DPL
   \   00001B   AB83         MOV     R3,DPH
   \   00001D   8882         MOV     DPL,R0
   \   00001F   8983         MOV     DPH,R1
   \   000021   E0           MOVX    A,@DPTR
   \   000022   64FF         XRL     A,#0xff
   \   000024   70E6         JNZ     ??APSME_IsDefaultTCLK_2
   3917              {
   3918                return FALSE;
   3919              }
   3920            }
   \                     ??APSME_IsDefaultTCLK_1:
   \   000026   EC           MOV     A,R4
   \   000027   0C           INC     R4
   \   000028   C3           CLR     C
   \   000029   9408         SUBB    A,#0x8
   \   00002B   40E3         JC      ??APSME_IsDefaultTCLK_4
   3921            
   3922            return TRUE;
   \   00002D   7901         MOV     R1,#0x1
   \                     ??APSME_IsDefaultTCLK_3:
   \   00002F   02....       LJMP    ??Subroutine100_0 & 0xFFFF
   3923          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 137, 103, 69, 35, 1, 239, 205, 171
   \            00000000
   \            89674523
   \            01EFCDAB

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemoveByExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyDataGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeySync?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsDefaultTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK
   3924          
   3925          
   3926          /******************************************************************************
   3927          ******************************************************************************/
   3928          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     APSME_IsDefaultTCLK                2      0     61
     APSME_KeyFwdToChild                0      0      9
       -> AssocGetWithExt               0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     APSME_LinkKeyDataGet               0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     APSME_LinkKeySet                   0      0     37
       -> ZDSecMgrEntryLookupExt        0      0     36
       -> osal_memcpy                   0      0     42
     APSME_MasterKeyGet                 0      0     11
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrMasterKeyLookup       0      0     22
     APSME_SKA_TimerExpired             0      0      0
     APSME_TCLinkKeyInit                0      0     46
       -> osal_memset                   0      0     86
       -> osal_memset                   0      0     86
       -> osal_memcpy                   0      0     92
       -> osal_nv_item_init             0      0     90
       -> osal_nv_item_init             0      0     90
     APSME_TCLinkKeyLoad                1      0     65
       -> APSME_LookupExtAddr           0      0    122
       -> AddrMgrExtAddrValid           0      0    122
       -> osal_nv_read                  0      0    130
       -> AddrMgrExtAddrEqual           0      0    122
       -> APSME_IsDefaultTCLK           0      0    122
       -> osal_memcpy                   0      0    128
       -> osal_nv_write                 0      0    130
       -> AddrMgrEntryLookupNwk         0      0    122
       -> AddrMgrEntryRelease           0      0    122
     APSME_TCLinkKeySync                2      0     52
       -> AddrMgrExtAddrValid           0      0     96
       -> APSME_LookupExtAddr           0      0     96
       -> osal_nv_read                  0      0    104
       -> AddrMgrExtAddrEqual           0      0     96
       -> APSME_IsDefaultTCLK           0      0     96
       -> osal_memcpy                   0      0    102
       -> osal_nv_write                 0      0    104
     ZDSecMgrAPSRemove                  2      0     12
       -> ZDSecMgrDeviceRemove          4      0     20
     ZDSecMgrAddLinkKey                 0      0     20
       -> ZDSecMgrAddrStore             0      0     36
       -> ZDSecMgrEntryLookupAMI        0      0     32
       -> ZDSecMgrEntryNew              0      0     32
       -> APSME_LinkKeySet              0      0     32
     ZDSecMgrAddrMgrUpdate              1      0     35
       -> AddrMgrEntryGet               0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAddrStore                  1      0     40
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAppKeyGet                  1      0     17
       -> SSP_GetTrueRand               0      0     18
     ZDSecMgrAppKeyReq                  1      0     49
       -> APSME_LookupNwkAddr           0      0     98
       -> APSME_LookupExtAddr           0      0     98
       -> SSP_GetTrueRand               0      0     98
       -> APSME_TransportKeyReq         0      0     98
       -> APSME_TransportKeyReq         0      0     98
     ZDSecMgrAssocDeviceAuth            2      0     35
     ZDSecMgrAuthInitiate               1      0     16
       -> APSME_LookupNwkAddr           0      0     32
       -> APSME_AuthenticateReq         0      0     32
     ZDSecMgrAuthNwkKey                 2      0     10
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateCfm            2      0      0
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateInd            1      0     32
       -> AddrMgrExtAddrSet             0      0     64
       -> AddrMgrEntryUpdate            0      0     64
       -> APSME_AuthenticateReq         0      0     64
     ZDSecMgrAuthenticationCheck        0      0      0
     ZDSecMgrAuthenticationSet          1      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     ZDSecMgrConfig                     2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrCtrlAdd                    0      0     26
       -> ZDSecMgrCtrlSet               0      0     28
     ZDSecMgrCtrlInit                   3      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrCtrlLookup                 0      0     23
     ZDSecMgrCtrlRelease                3      0      0
     ZDSecMgrCtrlReset                  0      0     14
       -> ZDSecMgrCtrlLookup            0      0     24
       -> ZDSecMgrCtrlSet               0      0     28
       -> ZDSecMgrCtrlAdd               0      0     24
     ZDSecMgrCtrlSet                    1      0     23
     ZDSecMgrCtrlTerm                   3      0      2
       -> ZDSecMgrCtrlLookup            4      0      4
     ZDSecMgrDeviceCtrlHandler          1      0     42
       -> ZDSecMgrSendMasterKey         0      0     18
       -> ZDSecMgrEstablishKey          0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> osal_start_timerEx            0      0     18
     ZDSecMgrDeviceCtrlSetup            3      0      0
       -> ZDSecMgrDeviceCtrlHandler     4      0      0
     ZDSecMgrDeviceCtrlUpdate           1      0     13
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> ZDSecMgrCtrlLookup            0      0     26
     ZDSecMgrDeviceEntryAdd             0      0     27
       -> ZDSecMgrEntryLookup           0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrEntryNew              0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
     ZDSecMgrDeviceEntryRemove          2      0      0
     ZDSecMgrDeviceJoin                 0      0     24
       -> ZDSecMgrDeviceValidate        0      0     24
       -> ZDSecMgrAddrStore             0      0     28
       -> ZDSecMgrSendNwkKey            0      0     24
       -> ZDSecMgrDeviceRemove          0      0     24
     ZDSecMgrDeviceJoinDirect           0      0      9
       -> ZDSecMgrDeviceJoin            0      0     18
       -> AssocGetWithShort             0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     ZDSecMgrDeviceJoinFwd              3      0      8
       -> APSME_UpdateDeviceReq         4      0     16
     ZDSecMgrDeviceNew                  2      0     35
       -> ZDSecMgrDeviceJoinFwd         4      0      0
     ZDSecMgrDeviceRemove               1      0     38
       -> NLME_GetShortAddr             0      0     38
       -> AssocGetWithExt               0      0     38
       -> NLME_LeaveReq                 0      0     38
       -> APSME_RemoveDeviceReq         0      0     38
     ZDSecMgrDeviceRemoveByExtAddr      2      0      2
       -> ZDSecMgrEntryLookupExt        4      0      4
     ZDSecMgrDeviceValidate             3      0     12
       -> ZDSecMgrDeviceValidateRM      4      0      0
     ZDSecMgrDeviceValidateCM           0      0     16
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLoad         0      0     28
       -> ZDSecMgrDeviceEntryAdd        0      0     28
     ZDSecMgrDeviceValidateRM           2      0      0
     ZDSecMgrDeviceValidateSKKE         0      0     42
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
       -> ZDSecMgrDeviceEntryAdd        0      0     26
     ZDSecMgrEntryFree                  2      0      0
     ZDSecMgrEntryInit                  2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrEntryLookup                1      0     36
       -> AddrMgrEntryLookupNwk         0      0     46
     ZDSecMgrEntryLookupAMI             0      0     27
     ZDSecMgrEntryLookupExt             0      0     29
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrEntryLookupAMI        0      0     22
     ZDSecMgrEntryNew                   1      0     27
     ZDSecMgrEstablishKey               1      0     26
       -> NLME_GetShortAddr             0      0     34
       -> APSME_EstablishKeyReq         0      0     34
     ZDSecMgrEstablishKeyCfm            0      0      0
     ZDSecMgrEstablishKeyInd            1      0     29
       -> ZDSecMgrTCDataLoad            0      0     58
       -> ZDSecMgrTCExtAddrCheck        0      0     58
       -> ZDSecMgrDeviceValidateSKKE
                                        0      0     58
       -> APSME_EstablishKeyRsp         0      0     58
     ZDSecMgrEvent                      1      0     33
       -> AddrMgrEntryGet               0      0     66
       -> ZDSecMgrDeviceCtrlHandler     0      0     66
       -> osal_start_timerEx            0      0     66
     ZDSecMgrExtAddrLookup              1      0     38
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryLookupExt         0      0     44
     ZDSecMgrExtAddrStore               1      0     24
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrInit                       2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrMasterKeyInit              2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrMasterKeyLoad              0      0     33
       -> ZDSecMgrExtAddrLookup         0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     32
       -> osal_memcpy                   0      0     38
       -> ZDSecMgrMasterKeyStore        0      0     32
     ZDSecMgrMasterKeyLookup            0      0     34
     ZDSecMgrMasterKeyStore             0      0     34
       -> osal_memcpy                   0      0     36
       -> osal_memset                   0      0     30
     ZDSecMgrNewDeviceEvent             1      0     35
       -> AssocMatchDeviceStatus        0      0     70
       -> ZDSecMgrAssocDeviceAuth       0      0     70
       -> AddrMgrEntryGet               0      0     70
       -> NLME_GetShortAddr             0      0     70
       -> ZDSecMgrDeviceNew             0      0     70
       -> AssocRemove                   0      0     70
     ZDSecMgrPermitJoining              2      0      0
     ZDSecMgrPermitJoiningTimeout       2      0      0
     ZDSecMgrRemoveDeviceInd            0      0     19
       -> APSME_LookupNwkAddr           0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> ZDSecMgrDeviceRemove          0      0     38
     ZDSecMgrRequestAppKey              3      0     12
       -> AddrMgrExtAddrLookup          4      0     24
       -> APSME_RequestKeyReq           4      0     24
     ZDSecMgrRequestKeyInd              2      0      0
       -> ZDSecMgrAppKeyReq             4      0      0
     ZDSecMgrSendMasterKey              1      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     46
       -> NLME_GetShortAddr             0      0     46
       -> APSME_TransportKeyReq         0      0     46
     ZDSecMgrSendNwkKey                 1      0     37
       -> NLME_GetShortAddr             0      0     50
       -> NLME_GetShortAddr             0      0     50
       -> APSME_TransportKeyReq         0      0     50
     ZDSecMgrSetupPartner               1      0     24
       -> AddrMgrExtAddrSet             0      0     48
       -> AddrMgrEntryUpdate            0      0     48
       -> ZDP_NwkAddrReq                0      0     48
       -> AddrMgrExtAddrValid           0      0     48
       -> ZDP_IEEEAddrReq               0      0     48
     ZDSecMgrSwitchKeyInd               2      0      0
       -> SSP_SwitchNwkKey              4      0      0
       -> ZDApp_NVUpdate                4      0      0
     ZDSecMgrTCDataLoad                 0      0     45
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     28
       -> ZDSecMgrMasterKeyStore        0      0     28
     ZDSecMgrTCExtAddrCheck             0      0     46
       -> AddrMgrExtAddrLookup          0      0     34
       -> AddrMgrExtAddrEqual           0      0     34
     ZDSecMgrTransportKeyInd            0      0     10
       -> ZDSecMgrTCDataLoad            0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> ZDSecMgrAuthNwkKey            0      0     20
     ZDSecMgrUpdateDeviceInd            2      0     10
       -> ZDSecMgrDeviceJoin            4      0     20


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     ZDSecMgrTCExtAddr                         8
     ZDSecMgrTCMasterKey                      16
     ZDSecMgrTCAuthenticated                   1
     ZDSecMgrTCDataLoaded                      1
     ZDSecMgrMasterKeyData                     2
     ZDSecMgrEntries                           2
     ZDSecMgrCtrlData                          2
     ZDSecMgrPermitJoiningEnabled              1
     ZDSecMgrPermitJoiningTimed                1
     TrustCenterLinkKey                       32
     ZDSecMgrMasterKeyInit                    61
     ?Subroutine2                              6
     ??Subroutine85_0                          5
     ?Subroutine54                            11
     ?Subroutine64                            16
     ??Subroutine100_0                         7
     ?Subroutine13                             6
     ??Subroutine109_0                         7
     ZDSecMgrAddrStore                        53
     ?Subroutine50                            10
     ?Subroutine19                            19
     ?Subroutine14                             9
     ?Subroutine12                             8
     ?Subroutine7                              3
     ??Subroutine86_0                          6
     ?Subroutine55                            10
     ?Subroutine81                             5
     ?Subroutine65                            13
     ?Subroutine73                             5
     ??Subroutine95_0                          3
     ??Subroutine96_0                          5
     ?Subroutine62                             6
     ??Subroutine107_0                         6
     ZDSecMgrExtAddrStore                     53
     ZDSecMgrExtAddrLookup                    61
     ZDSecMgrMasterKeyLookup                  93
     ??Subroutine87_0                          5
     ?Subroutine21                            19
     ?Subroutine43                            16
     ZDSecMgrMasterKeyStore                  139
     ?Subroutine45                            16
     ?Subroutine9                              4
     ??Subroutine112_0                         8
     ?Subroutine67                             6
     ZDSecMgrEntryInit                        71
     ZDSecMgrEntryLookup                     144
     ?Subroutine46                             4
     ?Subroutine69                             1
     ?Subroutine71                             7
     ?Subroutine76                             2
     ??Subroutine91_0                          3
     ??Subroutine92_0                          5
     ?Subroutine1                              4
     ??Subroutine101_0                         4
     ??Subroutine106_0                         4
     ?Subroutine61                             6
     ZDSecMgrEntryLookupAMI                   75
     ?Subroutine15                            11
     ZDSecMgrEntryLookupExt                   60
     ?Subroutine74                             2
     ??Subroutine94_0                          2
     ?Subroutine58                             6
     ?Subroutine35                             7
     ZDSecMgrEntryFree                         3
     ?Subroutine70                             7
     ??Subroutine99_0                          1
     ?Subroutine63                             4
     ZDSecMgrEntryNew                        110
     ZDSecMgrCtrlInit                         70
     ZDSecMgrCtrlRelease                      17
     ZDSecMgrCtrlLookup                      118
     ZDSecMgrCtrlSet                          92
     ?Subroutine10                             6
     ?Subroutine72                             6
     ??Subroutine104_0                         4
     ZDSecMgrCtrlAdd                         108
     ??Subroutine103_0                         5
     ZDSecMgrCtrlTerm                         40
     ?Subroutine51                            11
     ?Subroutine80                             2
     ??Subroutine110_0                         6
     ZDSecMgrCtrlReset                        81
     ?Subroutine83                             5
     ZDSecMgrMasterKeyLoad                    86
     ?Subroutine24                            15
     ?Subroutine77                             2
     ??Subroutine102_0                         3
     ?Subroutine38                            13
     ?Subroutine57                             9
     ??Subroutine114_0                         7
     ZDSecMgrAppKeyType                        1
     ZDSecMgrAppKeyGet                        49
     ?Subroutine36                             5
     ?Subroutine41                             4
     ??Subroutine97_0                          4
     ZDSecMgrAppKeyReq                       230
     ?Subroutine30                             6
     ??Subroutine90_0                          8
     ?Subroutine6                              9
     ??Subroutine108_0                         6
     ?Subroutine44                            26
     ZDSecMgrEstablishKey                     95
     ?Subroutine31                            11
     ??Subroutine88_0                          6
     ?Subroutine16                             6
     ??Subroutine89_0                          6
     ZDSecMgrSendMasterKey                   126
     ?Subroutine5                             11
     ?Subroutine56                             2
     ?Subroutine28                             8
     ?Subroutine3                              6
     ?Subroutine39                             4
     ?Subroutine60                             4
     ?Subroutine68                             9
     ZDSecMgrSendNwkKey                      192
     ?Subroutine48                             2
     ??Subroutine93_0                          6
     ??Subroutine105_0                         6
     ?Subroutine32                             6
     ZDSecMgrDeviceEntryRemove                 3
     ZDSecMgrDeviceRemoveByExtAddr            35
     ZDSecMgrAddrMgrUpdate                    66
     ?Subroutine75                             3
     ZDSecMgrDeviceEntryAdd                  172
     ?Subroutine33                            12
     ?Subroutine11                             8
     ?Subroutine29                             6
     ??Subroutine113_0                         4
     ZDSecMgrDeviceCtrlHandler               114
     ?Subroutine27                             8
     ?Subroutine53                             6
     ?Subroutine23                             8
     ZDSecMgrDeviceCtrlSetup                  62
     ZDSecMgrDeviceCtrlUpdate                102
     ?Subroutine82                             5
     ?Subroutine59                            11
     APSME_SKA_TimerExpired                    3
     ZDSecMgrDeviceRemove                    182
     ?Subroutine17                             6
     ?Subroutine40                             7
     ZDSecMgrDeviceValidateSKKE               55
     ?Subroutine26                            19
     ZDSecMgrDeviceValidateRM                 17
     ZDSecMgrDeviceValidateCM                 84
     ?Subroutine20                            18
     ZDSecMgrDeviceValidate                   48
     ZDSecMgrDeviceJoin                       75
     ZDSecMgrDeviceJoinDirect                 35
     ZDSecMgrDeviceJoinFwd                   155
     ?Subroutine49                             3
     ??Subroutine98_0                          5
     ??Subroutine111_0                         5
     ?Subroutine4                             13
     ZDSecMgrDeviceNew                         9
     ZDSecMgrAssocDeviceAuth                  25
     ZDSecMgrAuthInitiate                     66
     ZDSecMgrAuthNwkKey                       26
     ZDSecMgrInit                              0
     ?Subroutine79                             9
     ZDSecMgrConfig                            2
     ZDSecMgrPermitJoining                    40
     ZDSecMgrPermitJoiningTimeout             24
     ZDSecMgrNewDeviceEvent                  194
     ?Subroutine18                             3
     ZDSecMgrEvent                           264
     ?Subroutine0                              8
     ZDSecMgrEstablishKeyCfm                   3
     ZDSecMgrTCExtAddrCheck                   64
     ZDSecMgrTCDataLoad                       88
     ?Subroutine37                             6
     ZDSecMgrEstablishKeyInd                 204
     ?Subroutine8                             11
     ?Subroutine47                            15
     ?Subroutine52                            11
     ZDSecMgrTransportKeyInd                 139
     ZDSecMgrUpdateDeviceInd                  46
     ?Subroutine84                             4
     ZDSecMgrRemoveDeviceInd                  62
     ZDSecMgrRequestKeyInd                    30
     ZDSecMgrSwitchKeyInd                     23
     ZDSecMgrAuthenticateInd                 127
     ZDSecMgrAuthenticateCfm                  46
     ZDSecMgrRequestAppKey                    69
     ZDSecMgrSetupPartner                    109
     APSME_MasterKeyGet                       58
     APSME_LinkKeySet                        112
     ?Subroutine78                             8
     ?Subroutine34                             6
     ?Subroutine42                            10
     ZDSecMgrAuthenticationSet                52
     ZDSecMgrAuthenticationCheck               5
     APSME_LinkKeyDataGet                     85
     APSME_KeyFwdToChild                      62
     ZDSecMgrAddLinkKey                      143
     ZDSecMgrAPSRemove                        82
     APSME_TCLinkKeyInit                     127
     APSME_TCLinkKeySync                     304
     ?Subroutine22                             3
     ?Subroutine66                             4
     APSME_TCLinkKeyLoad                     313
     APSME_IsDefaultTCLK                      50
     ?Subroutine25                             6
     ?<Initializer for ZDSecMgrTCMasterKey>   16
     ?<Initializer for ZDSecMgrAppKeyType>     1
     __Constant_0                              4
     __Constant_1                              4
     ??ZDSecMgrMasterKeyInit?relay             6
     ??ZDSecMgrAddrStore?relay                 6
     ??ZDSecMgrExtAddrStore?relay              6
     ??ZDSecMgrExtAddrLookup?relay             6
     ??ZDSecMgrMasterKeyLookup?relay           6
     ??ZDSecMgrMasterKeyStore?relay            6
     ??ZDSecMgrEntryInit?relay                 6
     ??ZDSecMgrEntryLookup?relay               6
     ??ZDSecMgrEntryLookupAMI?relay            6
     ??ZDSecMgrEntryLookupExt?relay            6
     ??ZDSecMgrEntryFree?relay                 6
     ??ZDSecMgrEntryNew?relay                  6
     ??ZDSecMgrCtrlInit?relay                  6
     ??ZDSecMgrCtrlRelease?relay               6
     ??ZDSecMgrCtrlLookup?relay                6
     ??ZDSecMgrCtrlSet?relay                   6
     ??ZDSecMgrCtrlAdd?relay                   6
     ??ZDSecMgrCtrlTerm?relay                  6
     ??ZDSecMgrCtrlReset?relay                 6
     ??ZDSecMgrMasterKeyLoad?relay             6
     ??ZDSecMgrAppKeyGet?relay                 6
     ??ZDSecMgrAppKeyReq?relay                 6
     ??ZDSecMgrEstablishKey?relay              6
     ??ZDSecMgrSendMasterKey?relay             6
     ??ZDSecMgrSendNwkKey?relay                6
     ??ZDSecMgrDeviceEntryRemove?relay         6
     ??ZDSecMgrDeviceRemoveByExtAddr?relay     6
     ??ZDSecMgrAddrMgrUpdate?relay             6
     ??ZDSecMgrDeviceEntryAdd?relay            6
     ??ZDSecMgrDeviceCtrlHandler?relay         6
     ??ZDSecMgrDeviceCtrlSetup?relay           6
     ??ZDSecMgrDeviceCtrlUpdate?relay          6
     ??APSME_SKA_TimerExpired?relay            6
     ??ZDSecMgrDeviceRemove?relay              6
     ??ZDSecMgrDeviceValidateSKKE?relay        6
     ??ZDSecMgrDeviceValidateRM?relay          6
     ??ZDSecMgrDeviceValidateCM?relay          6
     ??ZDSecMgrDeviceValidate?relay            6
     ??ZDSecMgrDeviceJoin?relay                6
     ??ZDSecMgrDeviceJoinDirect?relay          6
     ??ZDSecMgrDeviceJoinFwd?relay             6
     ??ZDSecMgrDeviceNew?relay                 6
     ??ZDSecMgrAssocDeviceAuth?relay           6
     ??ZDSecMgrAuthInitiate?relay              6
     ??ZDSecMgrAuthNwkKey?relay                6
     ??ZDSecMgrInit?relay                      6
     ??ZDSecMgrConfig?relay                    6
     ??ZDSecMgrPermitJoining?relay             6
     ??ZDSecMgrPermitJoiningTimeout?relay      6
     ??ZDSecMgrNewDeviceEvent?relay            6
     ??ZDSecMgrEvent?relay                     6
     ??ZDSecMgrEstablishKeyCfm?relay           6
     ??ZDSecMgrTCExtAddrCheck?relay            6
     ??ZDSecMgrTCDataLoad?relay                6
     ??ZDSecMgrEstablishKeyInd?relay           6
     ??ZDSecMgrTransportKeyInd?relay           6
     ??ZDSecMgrUpdateDeviceInd?relay           6
     ??ZDSecMgrRemoveDeviceInd?relay           6
     ??ZDSecMgrRequestKeyInd?relay             6
     ??ZDSecMgrSwitchKeyInd?relay              6
     ??ZDSecMgrAuthenticateInd?relay           6
     ??ZDSecMgrAuthenticateCfm?relay           6
     ??ZDSecMgrRequestAppKey?relay             6
     ??ZDSecMgrSetupPartner?relay              6
     ??APSME_MasterKeyGet?relay                6
     ??APSME_LinkKeySet?relay                  6
     ??ZDSecMgrAuthenticationSet?relay         6
     ??ZDSecMgrAuthenticationCheck?relay       6
     ??APSME_LinkKeyDataGet?relay              6
     ??APSME_KeyFwdToChild?relay               6
     ??ZDSecMgrAddLinkKey?relay                6
     ??ZDSecMgrAPSRemove?relay                 6
     ??APSME_TCLinkKeyInit?relay               6
     ??APSME_TCLinkKeySync?relay               6
     ??APSME_TCLinkKeyLoad?relay               6
     ??APSME_IsDefaultTCLK?relay               6

 
 7 314 bytes in segment BANKED_CODE
   456 bytes in segment BANK_RELAYS
    17 bytes in segment XDATA_I
    17 bytes in segment XDATA_ID
     8 bytes in segment XDATA_ROM_C
    50 bytes in segment XDATA_Z
 
 7 787 bytes of CODE  memory
     0 bytes of CONST memory (+ 8 bytes shared)
    67 bytes of XDATA memory

Errors: none
Warnings: none
